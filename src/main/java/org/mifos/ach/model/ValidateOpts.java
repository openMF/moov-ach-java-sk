/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * ValidateOpts
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class ValidateOpts {
  public static final String SERIALIZED_NAME_REQUIRE_A_B_A_ORIGIN = "requireABAOrigin";
  @SerializedName(SERIALIZED_NAME_REQUIRE_A_B_A_ORIGIN)
  @javax.annotation.Nullable
  private Boolean requireABAOrigin = false;

  public static final String SERIALIZED_NAME_BYPASS_ORIGIN_VALIDATION = "bypassOriginValidation";
  @SerializedName(SERIALIZED_NAME_BYPASS_ORIGIN_VALIDATION)
  @javax.annotation.Nullable
  private Boolean bypassOriginValidation = false;

  public static final String SERIALIZED_NAME_BYPASS_DESTINATION_VALIDATION = "bypassDestinationValidation";
  @SerializedName(SERIALIZED_NAME_BYPASS_DESTINATION_VALIDATION)
  @javax.annotation.Nullable
  private Boolean bypassDestinationValidation = false;

  public static final String SERIALIZED_NAME_CUSTOM_TRACE_NUMBERS = "customTraceNumbers";
  @SerializedName(SERIALIZED_NAME_CUSTOM_TRACE_NUMBERS)
  @javax.annotation.Nullable
  private Boolean customTraceNumbers = false;

  public static final String SERIALIZED_NAME_ALLOW_ZERO_BATCHES = "allowZeroBatches";
  @SerializedName(SERIALIZED_NAME_ALLOW_ZERO_BATCHES)
  @javax.annotation.Nullable
  private Boolean allowZeroBatches = false;

  public static final String SERIALIZED_NAME_ALLOW_MISSING_FILE_HEADER = "allowMissingFileHeader";
  @SerializedName(SERIALIZED_NAME_ALLOW_MISSING_FILE_HEADER)
  @javax.annotation.Nullable
  private Boolean allowMissingFileHeader = false;

  public static final String SERIALIZED_NAME_ALLOW_MISSING_FILE_CONTROL = "allowMissingFileControl";
  @SerializedName(SERIALIZED_NAME_ALLOW_MISSING_FILE_CONTROL)
  @javax.annotation.Nullable
  private Boolean allowMissingFileControl = false;

  public static final String SERIALIZED_NAME_BYPASS_COMPANY_IDENTIFICATION_MATCH = "bypassCompanyIdentificationMatch";
  @SerializedName(SERIALIZED_NAME_BYPASS_COMPANY_IDENTIFICATION_MATCH)
  @javax.annotation.Nullable
  private Boolean bypassCompanyIdentificationMatch = false;

  public static final String SERIALIZED_NAME_CUSTOM_RETURN_CODES = "customReturnCodes";
  @SerializedName(SERIALIZED_NAME_CUSTOM_RETURN_CODES)
  @javax.annotation.Nullable
  private Boolean customReturnCodes = false;

  public static final String SERIALIZED_NAME_UNEQUAL_SERVICE_CLASS_CODE = "unequalServiceClassCode";
  @SerializedName(SERIALIZED_NAME_UNEQUAL_SERVICE_CLASS_CODE)
  @javax.annotation.Nullable
  private Boolean unequalServiceClassCode = false;

  public static final String SERIALIZED_NAME_UNORDERED_BATCH_NUMBERS = "unorderedBatchNumbers";
  @SerializedName(SERIALIZED_NAME_UNORDERED_BATCH_NUMBERS)
  @javax.annotation.Nullable
  private Boolean unorderedBatchNumbers = false;

  public static final String SERIALIZED_NAME_ALLOW_INVALID_CHECK_DIGIT = "allowInvalidCheckDigit";
  @SerializedName(SERIALIZED_NAME_ALLOW_INVALID_CHECK_DIGIT)
  @javax.annotation.Nullable
  private Boolean allowInvalidCheckDigit = false;

  public static final String SERIALIZED_NAME_UNEQUAL_ADDENDA_COUNTS = "unequalAddendaCounts";
  @SerializedName(SERIALIZED_NAME_UNEQUAL_ADDENDA_COUNTS)
  @javax.annotation.Nullable
  private Boolean unequalAddendaCounts = false;

  public static final String SERIALIZED_NAME_PRESERVE_SPACES = "preserveSpaces";
  @SerializedName(SERIALIZED_NAME_PRESERVE_SPACES)
  @javax.annotation.Nullable
  private Boolean preserveSpaces = false;

  public static final String SERIALIZED_NAME_ALLOW_INVALID_AMOUNTS = "allowInvalidAmounts";
  @SerializedName(SERIALIZED_NAME_ALLOW_INVALID_AMOUNTS)
  @javax.annotation.Nullable
  private Boolean allowInvalidAmounts = false;

  public static final String SERIALIZED_NAME_ALLOW_ZERO_ENTRY_AMOUNT = "allowZeroEntryAmount";
  @SerializedName(SERIALIZED_NAME_ALLOW_ZERO_ENTRY_AMOUNT)
  @javax.annotation.Nullable
  private Boolean allowZeroEntryAmount = false;

  public static final String SERIALIZED_NAME_ALLOW_SPECIAL_CHARACTERS = "allowSpecialCharacters";
  @SerializedName(SERIALIZED_NAME_ALLOW_SPECIAL_CHARACTERS)
  @javax.annotation.Nullable
  private Boolean allowSpecialCharacters = false;

  public ValidateOpts() {
  }

  public ValidateOpts requireABAOrigin(@javax.annotation.Nullable Boolean requireABAOrigin) {
    this.requireABAOrigin = requireABAOrigin;
    return this;
  }

  /**
   * Require that the FileHeader ImmediateOrigin routing number which checksum matches.
   * @return requireABAOrigin
   */
  @javax.annotation.Nullable
  public Boolean getRequireABAOrigin() {
    return requireABAOrigin;
  }

  public void setRequireABAOrigin(@javax.annotation.Nullable Boolean requireABAOrigin) {
    this.requireABAOrigin = requireABAOrigin;
  }


  public ValidateOpts bypassOriginValidation(@javax.annotation.Nullable Boolean bypassOriginValidation) {
    this.bypassOriginValidation = bypassOriginValidation;
    return this;
  }

  /**
   * Skip ImmediateOrigin validation steps.
   * @return bypassOriginValidation
   */
  @javax.annotation.Nullable
  public Boolean getBypassOriginValidation() {
    return bypassOriginValidation;
  }

  public void setBypassOriginValidation(@javax.annotation.Nullable Boolean bypassOriginValidation) {
    this.bypassOriginValidation = bypassOriginValidation;
  }


  public ValidateOpts bypassDestinationValidation(@javax.annotation.Nullable Boolean bypassDestinationValidation) {
    this.bypassDestinationValidation = bypassDestinationValidation;
    return this;
  }

  /**
   * Skip ImmediateDestination validation steps.
   * @return bypassDestinationValidation
   */
  @javax.annotation.Nullable
  public Boolean getBypassDestinationValidation() {
    return bypassDestinationValidation;
  }

  public void setBypassDestinationValidation(@javax.annotation.Nullable Boolean bypassDestinationValidation) {
    this.bypassDestinationValidation = bypassDestinationValidation;
  }


  public ValidateOpts customTraceNumbers(@javax.annotation.Nullable Boolean customTraceNumbers) {
    this.customTraceNumbers = customTraceNumbers;
    return this;
  }

  /**
   * Disable Nacha specified checks of TraceNumbers.
   * @return customTraceNumbers
   */
  @javax.annotation.Nullable
  public Boolean getCustomTraceNumbers() {
    return customTraceNumbers;
  }

  public void setCustomTraceNumbers(@javax.annotation.Nullable Boolean customTraceNumbers) {
    this.customTraceNumbers = customTraceNumbers;
  }


  public ValidateOpts allowZeroBatches(@javax.annotation.Nullable Boolean allowZeroBatches) {
    this.allowZeroBatches = allowZeroBatches;
    return this;
  }

  /**
   * Allow the file to have zero batches.
   * @return allowZeroBatches
   */
  @javax.annotation.Nullable
  public Boolean getAllowZeroBatches() {
    return allowZeroBatches;
  }

  public void setAllowZeroBatches(@javax.annotation.Nullable Boolean allowZeroBatches) {
    this.allowZeroBatches = allowZeroBatches;
  }


  public ValidateOpts allowMissingFileHeader(@javax.annotation.Nullable Boolean allowMissingFileHeader) {
    this.allowMissingFileHeader = allowMissingFileHeader;
    return this;
  }

  /**
   * Allow the file to be read without a FileHeader record.
   * @return allowMissingFileHeader
   */
  @javax.annotation.Nullable
  public Boolean getAllowMissingFileHeader() {
    return allowMissingFileHeader;
  }

  public void setAllowMissingFileHeader(@javax.annotation.Nullable Boolean allowMissingFileHeader) {
    this.allowMissingFileHeader = allowMissingFileHeader;
  }


  public ValidateOpts allowMissingFileControl(@javax.annotation.Nullable Boolean allowMissingFileControl) {
    this.allowMissingFileControl = allowMissingFileControl;
    return this;
  }

  /**
   * Allow the file to be read without a FileControl record.
   * @return allowMissingFileControl
   */
  @javax.annotation.Nullable
  public Boolean getAllowMissingFileControl() {
    return allowMissingFileControl;
  }

  public void setAllowMissingFileControl(@javax.annotation.Nullable Boolean allowMissingFileControl) {
    this.allowMissingFileControl = allowMissingFileControl;
  }


  public ValidateOpts bypassCompanyIdentificationMatch(@javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch) {
    this.bypassCompanyIdentificationMatch = bypassCompanyIdentificationMatch;
    return this;
  }

  /**
   * Allow batches in which the Company Identification field in the batch header and control do not match.
   * @return bypassCompanyIdentificationMatch
   */
  @javax.annotation.Nullable
  public Boolean getBypassCompanyIdentificationMatch() {
    return bypassCompanyIdentificationMatch;
  }

  public void setBypassCompanyIdentificationMatch(@javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch) {
    this.bypassCompanyIdentificationMatch = bypassCompanyIdentificationMatch;
  }


  public ValidateOpts customReturnCodes(@javax.annotation.Nullable Boolean customReturnCodes) {
    this.customReturnCodes = customReturnCodes;
    return this;
  }

  /**
   * Allow for non-standard/deprecated return codes (e.g. R97)
   * @return customReturnCodes
   */
  @javax.annotation.Nullable
  public Boolean getCustomReturnCodes() {
    return customReturnCodes;
  }

  public void setCustomReturnCodes(@javax.annotation.Nullable Boolean customReturnCodes) {
    this.customReturnCodes = customReturnCodes;
  }


  public ValidateOpts unequalServiceClassCode(@javax.annotation.Nullable Boolean unequalServiceClassCode) {
    this.unequalServiceClassCode = unequalServiceClassCode;
    return this;
  }

  /**
   * Skip equality checks for the ServiceClassCode in each pair of BatchHeader and BatchControl records.
   * @return unequalServiceClassCode
   */
  @javax.annotation.Nullable
  public Boolean getUnequalServiceClassCode() {
    return unequalServiceClassCode;
  }

  public void setUnequalServiceClassCode(@javax.annotation.Nullable Boolean unequalServiceClassCode) {
    this.unequalServiceClassCode = unequalServiceClassCode;
  }


  public ValidateOpts unorderedBatchNumbers(@javax.annotation.Nullable Boolean unorderedBatchNumbers) {
    this.unorderedBatchNumbers = unorderedBatchNumbers;
    return this;
  }

  /**
   * Allow a file to be read with unordered batch numbers.
   * @return unorderedBatchNumbers
   */
  @javax.annotation.Nullable
  public Boolean getUnorderedBatchNumbers() {
    return unorderedBatchNumbers;
  }

  public void setUnorderedBatchNumbers(@javax.annotation.Nullable Boolean unorderedBatchNumbers) {
    this.unorderedBatchNumbers = unorderedBatchNumbers;
  }


  public ValidateOpts allowInvalidCheckDigit(@javax.annotation.Nullable Boolean allowInvalidCheckDigit) {
    this.allowInvalidCheckDigit = allowInvalidCheckDigit;
    return this;
  }

  /**
   * Allow the CheckDigit field in EntryDetail to differ from the expected calculation
   * @return allowInvalidCheckDigit
   */
  @javax.annotation.Nullable
  public Boolean getAllowInvalidCheckDigit() {
    return allowInvalidCheckDigit;
  }

  public void setAllowInvalidCheckDigit(@javax.annotation.Nullable Boolean allowInvalidCheckDigit) {
    this.allowInvalidCheckDigit = allowInvalidCheckDigit;
  }


  public ValidateOpts unequalAddendaCounts(@javax.annotation.Nullable Boolean unequalAddendaCounts) {
    this.unequalAddendaCounts = unequalAddendaCounts;
    return this;
  }

  /**
   * Skip checking that Addenda Count fields match their expected and computed values.
   * @return unequalAddendaCounts
   */
  @javax.annotation.Nullable
  public Boolean getUnequalAddendaCounts() {
    return unequalAddendaCounts;
  }

  public void setUnequalAddendaCounts(@javax.annotation.Nullable Boolean unequalAddendaCounts) {
    this.unequalAddendaCounts = unequalAddendaCounts;
  }


  public ValidateOpts preserveSpaces(@javax.annotation.Nullable Boolean preserveSpaces) {
    this.preserveSpaces = preserveSpaces;
    return this;
  }

  /**
   * Keeps any spacing before and after values that normally have spaces trimmed during parsing.
   * @return preserveSpaces
   */
  @javax.annotation.Nullable
  public Boolean getPreserveSpaces() {
    return preserveSpaces;
  }

  public void setPreserveSpaces(@javax.annotation.Nullable Boolean preserveSpaces) {
    this.preserveSpaces = preserveSpaces;
  }


  public ValidateOpts allowInvalidAmounts(@javax.annotation.Nullable Boolean allowInvalidAmounts) {
    this.allowInvalidAmounts = allowInvalidAmounts;
    return this;
  }

  /**
   * Skip verifying the Amount is valid for the TransactionCode and entry type.
   * @return allowInvalidAmounts
   */
  @javax.annotation.Nullable
  public Boolean getAllowInvalidAmounts() {
    return allowInvalidAmounts;
  }

  public void setAllowInvalidAmounts(@javax.annotation.Nullable Boolean allowInvalidAmounts) {
    this.allowInvalidAmounts = allowInvalidAmounts;
  }


  public ValidateOpts allowZeroEntryAmount(@javax.annotation.Nullable Boolean allowZeroEntryAmount) {
    this.allowZeroEntryAmount = allowZeroEntryAmount;
    return this;
  }

  /**
   * Skip enforcing the entry Amount to be non-zero.
   * @return allowZeroEntryAmount
   */
  @javax.annotation.Nullable
  public Boolean getAllowZeroEntryAmount() {
    return allowZeroEntryAmount;
  }

  public void setAllowZeroEntryAmount(@javax.annotation.Nullable Boolean allowZeroEntryAmount) {
    this.allowZeroEntryAmount = allowZeroEntryAmount;
  }


  public ValidateOpts allowSpecialCharacters(@javax.annotation.Nullable Boolean allowSpecialCharacters) {
    this.allowSpecialCharacters = allowSpecialCharacters;
    return this;
  }

  /**
   * Permit a wider range of UTF-8 characters in alphanumeric fields.
   * @return allowSpecialCharacters
   */
  @javax.annotation.Nullable
  public Boolean getAllowSpecialCharacters() {
    return allowSpecialCharacters;
  }

  public void setAllowSpecialCharacters(@javax.annotation.Nullable Boolean allowSpecialCharacters) {
    this.allowSpecialCharacters = allowSpecialCharacters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValidateOpts validateOpts = (ValidateOpts) o;
    return Objects.equals(this.requireABAOrigin, validateOpts.requireABAOrigin) &&
        Objects.equals(this.bypassOriginValidation, validateOpts.bypassOriginValidation) &&
        Objects.equals(this.bypassDestinationValidation, validateOpts.bypassDestinationValidation) &&
        Objects.equals(this.customTraceNumbers, validateOpts.customTraceNumbers) &&
        Objects.equals(this.allowZeroBatches, validateOpts.allowZeroBatches) &&
        Objects.equals(this.allowMissingFileHeader, validateOpts.allowMissingFileHeader) &&
        Objects.equals(this.allowMissingFileControl, validateOpts.allowMissingFileControl) &&
        Objects.equals(this.bypassCompanyIdentificationMatch, validateOpts.bypassCompanyIdentificationMatch) &&
        Objects.equals(this.customReturnCodes, validateOpts.customReturnCodes) &&
        Objects.equals(this.unequalServiceClassCode, validateOpts.unequalServiceClassCode) &&
        Objects.equals(this.unorderedBatchNumbers, validateOpts.unorderedBatchNumbers) &&
        Objects.equals(this.allowInvalidCheckDigit, validateOpts.allowInvalidCheckDigit) &&
        Objects.equals(this.unequalAddendaCounts, validateOpts.unequalAddendaCounts) &&
        Objects.equals(this.preserveSpaces, validateOpts.preserveSpaces) &&
        Objects.equals(this.allowInvalidAmounts, validateOpts.allowInvalidAmounts) &&
        Objects.equals(this.allowZeroEntryAmount, validateOpts.allowZeroEntryAmount) &&
        Objects.equals(this.allowSpecialCharacters, validateOpts.allowSpecialCharacters);
  }

  @Override
  public int hashCode() {
    return Objects.hash(requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, unorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowZeroEntryAmount, allowSpecialCharacters);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValidateOpts {\n");
    sb.append("    requireABAOrigin: ").append(toIndentedString(requireABAOrigin)).append("\n");
    sb.append("    bypassOriginValidation: ").append(toIndentedString(bypassOriginValidation)).append("\n");
    sb.append("    bypassDestinationValidation: ").append(toIndentedString(bypassDestinationValidation)).append("\n");
    sb.append("    customTraceNumbers: ").append(toIndentedString(customTraceNumbers)).append("\n");
    sb.append("    allowZeroBatches: ").append(toIndentedString(allowZeroBatches)).append("\n");
    sb.append("    allowMissingFileHeader: ").append(toIndentedString(allowMissingFileHeader)).append("\n");
    sb.append("    allowMissingFileControl: ").append(toIndentedString(allowMissingFileControl)).append("\n");
    sb.append("    bypassCompanyIdentificationMatch: ").append(toIndentedString(bypassCompanyIdentificationMatch)).append("\n");
    sb.append("    customReturnCodes: ").append(toIndentedString(customReturnCodes)).append("\n");
    sb.append("    unequalServiceClassCode: ").append(toIndentedString(unequalServiceClassCode)).append("\n");
    sb.append("    unorderedBatchNumbers: ").append(toIndentedString(unorderedBatchNumbers)).append("\n");
    sb.append("    allowInvalidCheckDigit: ").append(toIndentedString(allowInvalidCheckDigit)).append("\n");
    sb.append("    unequalAddendaCounts: ").append(toIndentedString(unequalAddendaCounts)).append("\n");
    sb.append("    preserveSpaces: ").append(toIndentedString(preserveSpaces)).append("\n");
    sb.append("    allowInvalidAmounts: ").append(toIndentedString(allowInvalidAmounts)).append("\n");
    sb.append("    allowZeroEntryAmount: ").append(toIndentedString(allowZeroEntryAmount)).append("\n");
    sb.append("    allowSpecialCharacters: ").append(toIndentedString(allowSpecialCharacters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("requireABAOrigin", "bypassOriginValidation", "bypassDestinationValidation", "customTraceNumbers", "allowZeroBatches", "allowMissingFileHeader", "allowMissingFileControl", "bypassCompanyIdentificationMatch", "customReturnCodes", "unequalServiceClassCode", "unorderedBatchNumbers", "allowInvalidCheckDigit", "unequalAddendaCounts", "preserveSpaces", "allowInvalidAmounts", "allowZeroEntryAmount", "allowSpecialCharacters"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ValidateOpts
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ValidateOpts.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ValidateOpts is not found in the empty JSON string", ValidateOpts.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ValidateOpts.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ValidateOpts` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ValidateOpts.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ValidateOpts' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ValidateOpts> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ValidateOpts.class));

       return (TypeAdapter<T>) new TypeAdapter<ValidateOpts>() {
           @Override
           public void write(JsonWriter out, ValidateOpts value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ValidateOpts read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ValidateOpts given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ValidateOpts
   * @throws IOException if the JSON string is invalid with respect to ValidateOpts
   */
  public static ValidateOpts fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ValidateOpts.class);
  }

  /**
   * Convert an instance of ValidateOpts to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

