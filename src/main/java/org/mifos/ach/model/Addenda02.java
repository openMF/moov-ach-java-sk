/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * Addenda02
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class Addenda02 {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_TYPE_CODE = "typeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  @javax.annotation.Nonnull
  private String typeCode;

  public static final String SERIALIZED_NAME_REFERENCE_INFORMATION_ONE = "referenceInformationOne";
  @SerializedName(SERIALIZED_NAME_REFERENCE_INFORMATION_ONE)
  @javax.annotation.Nullable
  private String referenceInformationOne;

  public static final String SERIALIZED_NAME_REFERENCE_INFORMATION_TWO = "referenceInformationTwo";
  @SerializedName(SERIALIZED_NAME_REFERENCE_INFORMATION_TWO)
  @javax.annotation.Nullable
  private String referenceInformationTwo;

  public static final String SERIALIZED_NAME_TERMINAL_IDENTIFICATION_CODE = "terminalIdentificationCode";
  @SerializedName(SERIALIZED_NAME_TERMINAL_IDENTIFICATION_CODE)
  @javax.annotation.Nonnull
  private String terminalIdentificationCode;

  public static final String SERIALIZED_NAME_TRANSACTION_SERIAL_NUMBER = "transactionSerialNumber";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_SERIAL_NUMBER)
  @javax.annotation.Nonnull
  private String transactionSerialNumber;

  public static final String SERIALIZED_NAME_TRANSACTION_DATE = "transactionDate";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_DATE)
  @javax.annotation.Nonnull
  private String transactionDate;

  public static final String SERIALIZED_NAME_AUTHORIZATION_CODE_OR_EXPIRE_DATE = "authorizationCodeOrExpireDate";
  @SerializedName(SERIALIZED_NAME_AUTHORIZATION_CODE_OR_EXPIRE_DATE)
  @javax.annotation.Nullable
  private String authorizationCodeOrExpireDate;

  public static final String SERIALIZED_NAME_TERMINAL_LOCATION = "terminalLocation";
  @SerializedName(SERIALIZED_NAME_TERMINAL_LOCATION)
  @javax.annotation.Nonnull
  private String terminalLocation;

  public static final String SERIALIZED_NAME_TERMINAL_CITY = "terminalCity";
  @SerializedName(SERIALIZED_NAME_TERMINAL_CITY)
  @javax.annotation.Nonnull
  private String terminalCity;

  public static final String SERIALIZED_NAME_TERMINAL_STATE = "terminalState";
  @SerializedName(SERIALIZED_NAME_TERMINAL_STATE)
  @javax.annotation.Nonnull
  private String terminalState;

  public static final String SERIALIZED_NAME_TRACE_NUMBER = "traceNumber";
  @SerializedName(SERIALIZED_NAME_TRACE_NUMBER)
  @javax.annotation.Nullable
  private String traceNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public Addenda02() {
  }

  public Addenda02 id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Client-defined string used as a reference to this record.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public Addenda02 typeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * 02 - NACHA regulations
   * @return typeCode
   */
  @javax.annotation.Nonnull
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
  }


  public Addenda02 referenceInformationOne(@javax.annotation.Nullable String referenceInformationOne) {
    this.referenceInformationOne = referenceInformationOne;
    return this;
  }

  /**
   * ReferenceInformationOne may be used for additional reference numbers, identification numbers, or codes that the merchant needs to identify the particular transaction or customer. 
   * @return referenceInformationOne
   */
  @javax.annotation.Nullable
  public String getReferenceInformationOne() {
    return referenceInformationOne;
  }

  public void setReferenceInformationOne(@javax.annotation.Nullable String referenceInformationOne) {
    this.referenceInformationOne = referenceInformationOne;
  }


  public Addenda02 referenceInformationTwo(@javax.annotation.Nullable String referenceInformationTwo) {
    this.referenceInformationTwo = referenceInformationTwo;
    return this;
  }

  /**
   * ReferenceInformationTwo may be used for additional reference numbers, identification numbers, or codes that the merchant needs to identify the particular transaction or customer. 
   * @return referenceInformationTwo
   */
  @javax.annotation.Nullable
  public String getReferenceInformationTwo() {
    return referenceInformationTwo;
  }

  public void setReferenceInformationTwo(@javax.annotation.Nullable String referenceInformationTwo) {
    this.referenceInformationTwo = referenceInformationTwo;
  }


  public Addenda02 terminalIdentificationCode(@javax.annotation.Nonnull String terminalIdentificationCode) {
    this.terminalIdentificationCode = terminalIdentificationCode;
    return this;
  }

  /**
   * TerminalIdentificationCode identifies an Electronic terminal with a unique code that allows a terminal owner and/or switching network to identify the terminal at which an Entry originated. 
   * @return terminalIdentificationCode
   */
  @javax.annotation.Nonnull
  public String getTerminalIdentificationCode() {
    return terminalIdentificationCode;
  }

  public void setTerminalIdentificationCode(@javax.annotation.Nonnull String terminalIdentificationCode) {
    this.terminalIdentificationCode = terminalIdentificationCode;
  }


  public Addenda02 transactionSerialNumber(@javax.annotation.Nonnull String transactionSerialNumber) {
    this.transactionSerialNumber = transactionSerialNumber;
    return this;
  }

  /**
   * TransactionSerialNumber is assigned by the terminal at the time the transaction is originated.  The number, with the Terminal Identification Code, serves as an audit trail for the transaction and is usually assigned in ascending sequence. 
   * @return transactionSerialNumber
   */
  @javax.annotation.Nonnull
  public String getTransactionSerialNumber() {
    return transactionSerialNumber;
  }

  public void setTransactionSerialNumber(@javax.annotation.Nonnull String transactionSerialNumber) {
    this.transactionSerialNumber = transactionSerialNumber;
  }


  public Addenda02 transactionDate(@javax.annotation.Nonnull String transactionDate) {
    this.transactionDate = transactionDate;
    return this;
  }

  /**
   * Timestamp identifies the date on which the transaction occurred. (Format MMDD - M&#x3D;Month, D&#x3D;Day)
   * @return transactionDate
   */
  @javax.annotation.Nonnull
  public String getTransactionDate() {
    return transactionDate;
  }

  public void setTransactionDate(@javax.annotation.Nonnull String transactionDate) {
    this.transactionDate = transactionDate;
  }


  public Addenda02 authorizationCodeOrExpireDate(@javax.annotation.Nullable String authorizationCodeOrExpireDate) {
    this.authorizationCodeOrExpireDate = authorizationCodeOrExpireDate;
    return this;
  }

  /**
   * Indicates the code that a card authorization center has furnished to the merchant.
   * @return authorizationCodeOrExpireDate
   */
  @javax.annotation.Nullable
  public String getAuthorizationCodeOrExpireDate() {
    return authorizationCodeOrExpireDate;
  }

  public void setAuthorizationCodeOrExpireDate(@javax.annotation.Nullable String authorizationCodeOrExpireDate) {
    this.authorizationCodeOrExpireDate = authorizationCodeOrExpireDate;
  }


  public Addenda02 terminalLocation(@javax.annotation.Nonnull String terminalLocation) {
    this.terminalLocation = terminalLocation;
    return this;
  }

  /**
   * Identifies the specific location of a terminal (i.e., street names of an intersection, address, etc.) in accordance with the requirements of Regulation E.
   * @return terminalLocation
   */
  @javax.annotation.Nonnull
  public String getTerminalLocation() {
    return terminalLocation;
  }

  public void setTerminalLocation(@javax.annotation.Nonnull String terminalLocation) {
    this.terminalLocation = terminalLocation;
  }


  public Addenda02 terminalCity(@javax.annotation.Nonnull String terminalCity) {
    this.terminalCity = terminalCity;
    return this;
  }

  /**
   * Identifies the city in which the electronic terminal is located.
   * @return terminalCity
   */
  @javax.annotation.Nonnull
  public String getTerminalCity() {
    return terminalCity;
  }

  public void setTerminalCity(@javax.annotation.Nonnull String terminalCity) {
    this.terminalCity = terminalCity;
  }


  public Addenda02 terminalState(@javax.annotation.Nonnull String terminalState) {
    this.terminalState = terminalState;
    return this;
  }

  /**
   * Identifies the state in which the electronic terminal is located.
   * @return terminalState
   */
  @javax.annotation.Nonnull
  public String getTerminalState() {
    return terminalState;
  }

  public void setTerminalState(@javax.annotation.Nonnull String terminalState) {
    this.terminalState = terminalState;
  }


  public Addenda02 traceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
    return this;
  }

  /**
   * Entry Detail Trace Number
   * @return traceNumber
   */
  @javax.annotation.Nullable
  public String getTraceNumber() {
    return traceNumber;
  }

  public void setTraceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
  }


  public Addenda02 lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Addenda02 addenda02 = (Addenda02) o;
    return Objects.equals(this.id, addenda02.id) &&
        Objects.equals(this.typeCode, addenda02.typeCode) &&
        Objects.equals(this.referenceInformationOne, addenda02.referenceInformationOne) &&
        Objects.equals(this.referenceInformationTwo, addenda02.referenceInformationTwo) &&
        Objects.equals(this.terminalIdentificationCode, addenda02.terminalIdentificationCode) &&
        Objects.equals(this.transactionSerialNumber, addenda02.transactionSerialNumber) &&
        Objects.equals(this.transactionDate, addenda02.transactionDate) &&
        Objects.equals(this.authorizationCodeOrExpireDate, addenda02.authorizationCodeOrExpireDate) &&
        Objects.equals(this.terminalLocation, addenda02.terminalLocation) &&
        Objects.equals(this.terminalCity, addenda02.terminalCity) &&
        Objects.equals(this.terminalState, addenda02.terminalState) &&
        Objects.equals(this.traceNumber, addenda02.traceNumber) &&
        Objects.equals(this.lineNumber, addenda02.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, typeCode, referenceInformationOne, referenceInformationTwo, terminalIdentificationCode, transactionSerialNumber, transactionDate, authorizationCodeOrExpireDate, terminalLocation, terminalCity, terminalState, traceNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Addenda02 {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    referenceInformationOne: ").append(toIndentedString(referenceInformationOne)).append("\n");
    sb.append("    referenceInformationTwo: ").append(toIndentedString(referenceInformationTwo)).append("\n");
    sb.append("    terminalIdentificationCode: ").append(toIndentedString(terminalIdentificationCode)).append("\n");
    sb.append("    transactionSerialNumber: ").append(toIndentedString(transactionSerialNumber)).append("\n");
    sb.append("    transactionDate: ").append(toIndentedString(transactionDate)).append("\n");
    sb.append("    authorizationCodeOrExpireDate: ").append(toIndentedString(authorizationCodeOrExpireDate)).append("\n");
    sb.append("    terminalLocation: ").append(toIndentedString(terminalLocation)).append("\n");
    sb.append("    terminalCity: ").append(toIndentedString(terminalCity)).append("\n");
    sb.append("    terminalState: ").append(toIndentedString(terminalState)).append("\n");
    sb.append("    traceNumber: ").append(toIndentedString(traceNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "typeCode", "referenceInformationOne", "referenceInformationTwo", "terminalIdentificationCode", "transactionSerialNumber", "transactionDate", "authorizationCodeOrExpireDate", "terminalLocation", "terminalCity", "terminalState", "traceNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("typeCode", "terminalIdentificationCode", "transactionSerialNumber", "transactionDate", "terminalLocation", "terminalCity", "terminalState"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Addenda02
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Addenda02.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Addenda02 is not found in the empty JSON string", Addenda02.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Addenda02.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Addenda02` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Addenda02.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("typeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeCode").toString()));
      }
      if ((jsonObj.get("referenceInformationOne") != null && !jsonObj.get("referenceInformationOne").isJsonNull()) && !jsonObj.get("referenceInformationOne").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `referenceInformationOne` to be a primitive type in the JSON string but got `%s`", jsonObj.get("referenceInformationOne").toString()));
      }
      if ((jsonObj.get("referenceInformationTwo") != null && !jsonObj.get("referenceInformationTwo").isJsonNull()) && !jsonObj.get("referenceInformationTwo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `referenceInformationTwo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("referenceInformationTwo").toString()));
      }
      if (!jsonObj.get("terminalIdentificationCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminalIdentificationCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminalIdentificationCode").toString()));
      }
      if (!jsonObj.get("transactionSerialNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionSerialNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionSerialNumber").toString()));
      }
      if (!jsonObj.get("transactionDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionDate").toString()));
      }
      if ((jsonObj.get("authorizationCodeOrExpireDate") != null && !jsonObj.get("authorizationCodeOrExpireDate").isJsonNull()) && !jsonObj.get("authorizationCodeOrExpireDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizationCodeOrExpireDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorizationCodeOrExpireDate").toString()));
      }
      if (!jsonObj.get("terminalLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminalLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminalLocation").toString()));
      }
      if (!jsonObj.get("terminalCity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminalCity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminalCity").toString()));
      }
      if (!jsonObj.get("terminalState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminalState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminalState").toString()));
      }
      if ((jsonObj.get("traceNumber") != null && !jsonObj.get("traceNumber").isJsonNull()) && !jsonObj.get("traceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traceNumber").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Addenda02.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Addenda02' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Addenda02> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Addenda02.class));

       return (TypeAdapter<T>) new TypeAdapter<Addenda02>() {
           @Override
           public void write(JsonWriter out, Addenda02 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Addenda02 read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Addenda02 given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Addenda02
   * @throws IOException if the JSON string is invalid with respect to Addenda02
   */
  public static Addenda02 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Addenda02.class);
  }

  /**
   * Convert an instance of Addenda02 to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

