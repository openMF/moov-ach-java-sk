/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * IATBatchHeader
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class IATBatchHeader {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_SERVICE_CLASS_CODE = "serviceClassCode";
  @SerializedName(SERIALIZED_NAME_SERVICE_CLASS_CODE)
  @javax.annotation.Nonnull
  private Integer serviceClassCode;

  public static final String SERIALIZED_NAME_IA_T_INDICATOR = "IATIndicator";
  @SerializedName(SERIALIZED_NAME_IA_T_INDICATOR)
  @javax.annotation.Nullable
  private String iaTIndicator;

  public static final String SERIALIZED_NAME_FOREIGN_EXCHANGE_INDICATOR = "foreignExchangeIndicator";
  @SerializedName(SERIALIZED_NAME_FOREIGN_EXCHANGE_INDICATOR)
  @javax.annotation.Nonnull
  private String foreignExchangeIndicator;

  public static final String SERIALIZED_NAME_FOREIGN_EXCHANGE_REFERENCE_INDICATOR = "foreignExchangeReferenceIndicator";
  @SerializedName(SERIALIZED_NAME_FOREIGN_EXCHANGE_REFERENCE_INDICATOR)
  @javax.annotation.Nonnull
  private Integer foreignExchangeReferenceIndicator;

  public static final String SERIALIZED_NAME_FOREIGN_EXCHANGE_REFERENCE = "foreignExchangeReference";
  @SerializedName(SERIALIZED_NAME_FOREIGN_EXCHANGE_REFERENCE)
  @javax.annotation.Nonnull
  private String foreignExchangeReference;

  public static final String SERIALIZED_NAME_IS_O_DESTINATION_COUNTRY_CODE = "ISODestinationCountryCode";
  @SerializedName(SERIALIZED_NAME_IS_O_DESTINATION_COUNTRY_CODE)
  @javax.annotation.Nonnull
  private String isODestinationCountryCode;

  public static final String SERIALIZED_NAME_ORIGINATOR_IDENTIFICATION = "originatorIdentification";
  @SerializedName(SERIALIZED_NAME_ORIGINATOR_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String originatorIdentification;

  public static final String SERIALIZED_NAME_STANDARD_ENTRY_CLASS_CODE = "standardEntryClassCode";
  @SerializedName(SERIALIZED_NAME_STANDARD_ENTRY_CLASS_CODE)
  @javax.annotation.Nonnull
  private String standardEntryClassCode;

  public static final String SERIALIZED_NAME_COMPANY_ENTRY_DESCRIPTION = "companyEntryDescription";
  @SerializedName(SERIALIZED_NAME_COMPANY_ENTRY_DESCRIPTION)
  @javax.annotation.Nullable
  private String companyEntryDescription;

  public static final String SERIALIZED_NAME_IS_O_ORIGINATING_CURRENCY_CODE = "ISOOriginatingCurrencyCode";
  @SerializedName(SERIALIZED_NAME_IS_O_ORIGINATING_CURRENCY_CODE)
  @javax.annotation.Nonnull
  private String isOOriginatingCurrencyCode;

  public static final String SERIALIZED_NAME_IS_O_DESTINATION_CURRENCY_CODE = "ISODestinationCurrencyCode";
  @SerializedName(SERIALIZED_NAME_IS_O_DESTINATION_CURRENCY_CODE)
  @javax.annotation.Nonnull
  private String isODestinationCurrencyCode;

  public static final String SERIALIZED_NAME_EFFECTIVE_ENTRY_DATE = "effectiveEntryDate";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_ENTRY_DATE)
  @javax.annotation.Nullable
  private String effectiveEntryDate;

  public static final String SERIALIZED_NAME_ORIGINATOR_STATUS_CODE = "originatorStatusCode";
  @SerializedName(SERIALIZED_NAME_ORIGINATOR_STATUS_CODE)
  @javax.annotation.Nullable
  private Integer originatorStatusCode;

  public static final String SERIALIZED_NAME_OD_F_I_IDENTIFICATION = "ODFIIdentification";
  @SerializedName(SERIALIZED_NAME_OD_F_I_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String odFIIdentification;

  public static final String SERIALIZED_NAME_BATCH_NUMBER = "batchNumber";
  @SerializedName(SERIALIZED_NAME_BATCH_NUMBER)
  @javax.annotation.Nonnull
  private Integer batchNumber;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  @javax.annotation.Nullable
  private String settlementDate;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public IATBatchHeader() {
  }

  public IATBatchHeader id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * ID is a client-defined string used as a reference to this record.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public IATBatchHeader serviceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
    return this;
  }

  /**
   * Service Class Code - Mixed Debits and Credits &#39;200&#39;, ACH Credits Only &#39;220&#39;, or ACH Debits Only &#39;225&#39;
   * @return serviceClassCode
   */
  @javax.annotation.Nonnull
  public Integer getServiceClassCode() {
    return serviceClassCode;
  }

  public void setServiceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
  }


  public IATBatchHeader iaTIndicator(@javax.annotation.Nullable String iaTIndicator) {
    this.iaTIndicator = iaTIndicator;
    return this;
  }

  /**
   * Leave Blank. Only used for corrected IAT entries
   * @return iaTIndicator
   */
  @javax.annotation.Nullable
  public String getIaTIndicator() {
    return iaTIndicator;
  }

  public void setIaTIndicator(@javax.annotation.Nullable String iaTIndicator) {
    this.iaTIndicator = iaTIndicator;
  }


  public IATBatchHeader foreignExchangeIndicator(@javax.annotation.Nonnull String foreignExchangeIndicator) {
    this.foreignExchangeIndicator = foreignExchangeIndicator;
    return this;
  }

  /**
   * Code indicating currency conversion: &#39;FV&#39; (Fixed-to-Variable) – Entry is originated in a fixed-value amount and is to be received in a variable amount resulting from the execution of the foreign exchange conversion. | &#39;VF&#39; (Variable-to-Fixed) – Entry is originated in a variable-value amount based on a specific foreign exchange rate for conversion to a fixed-value amount in which the entry is to be received. | &#39;FF&#39; (Fixed-to-Fixed) – Entry is originated in a fixed-value amount and is to be received in the same fixed-value amount in the same currency denomination. There is no foreign exchange conversion for entries transmitted using this code. For entries originated in a fixed value amount, the foreign Exchange Reference Field will be space filled. 
   * @return foreignExchangeIndicator
   */
  @javax.annotation.Nonnull
  public String getForeignExchangeIndicator() {
    return foreignExchangeIndicator;
  }

  public void setForeignExchangeIndicator(@javax.annotation.Nonnull String foreignExchangeIndicator) {
    this.foreignExchangeIndicator = foreignExchangeIndicator;
  }


  public IATBatchHeader foreignExchangeReferenceIndicator(@javax.annotation.Nonnull Integer foreignExchangeReferenceIndicator) {
    this.foreignExchangeReferenceIndicator = foreignExchangeReferenceIndicator;
    return this;
  }

  /**
   * Code used to indicate the content of the Foreign Exchange Reference Field and is filled by the gateway operator. Valid entries are 1 - Foreign Exchange Rate | 2 - Foreign Exchange Reference Number | 3 - Space Filled 
   * @return foreignExchangeReferenceIndicator
   */
  @javax.annotation.Nonnull
  public Integer getForeignExchangeReferenceIndicator() {
    return foreignExchangeReferenceIndicator;
  }

  public void setForeignExchangeReferenceIndicator(@javax.annotation.Nonnull Integer foreignExchangeReferenceIndicator) {
    this.foreignExchangeReferenceIndicator = foreignExchangeReferenceIndicator;
  }


  public IATBatchHeader foreignExchangeReference(@javax.annotation.Nonnull String foreignExchangeReference) {
    this.foreignExchangeReference = foreignExchangeReference;
    return this;
  }

  /**
   * Contains either the foreign exchange rate used to execute the foreign exchange conversion of a cross-border entry or another reference to the foreign exchange transaction.
   * @return foreignExchangeReference
   */
  @javax.annotation.Nonnull
  public String getForeignExchangeReference() {
    return foreignExchangeReference;
  }

  public void setForeignExchangeReference(@javax.annotation.Nonnull String foreignExchangeReference) {
    this.foreignExchangeReference = foreignExchangeReference;
  }


  public IATBatchHeader isODestinationCountryCode(@javax.annotation.Nonnull String isODestinationCountryCode) {
    this.isODestinationCountryCode = isODestinationCountryCode;
    return this;
  }

  /**
   * Two-character code, as approved by the International Organization for Standardization (ISO), to identify the country in which the entry is to be received. For United States use US.
   * @return isODestinationCountryCode
   */
  @javax.annotation.Nonnull
  public String getIsODestinationCountryCode() {
    return isODestinationCountryCode;
  }

  public void setIsODestinationCountryCode(@javax.annotation.Nonnull String isODestinationCountryCode) {
    this.isODestinationCountryCode = isODestinationCountryCode;
  }


  public IATBatchHeader originatorIdentification(@javax.annotation.Nonnull String originatorIdentification) {
    this.originatorIdentification = originatorIdentification;
    return this;
  }

  /**
   * For U.S. entities: the number assigned will be your tax ID (often Social Security Number) For non-U.S. entities: the number assigned will be your DDA number, or the last 9 characters of your account number if it exceeds 9 characters 
   * @return originatorIdentification
   */
  @javax.annotation.Nonnull
  public String getOriginatorIdentification() {
    return originatorIdentification;
  }

  public void setOriginatorIdentification(@javax.annotation.Nonnull String originatorIdentification) {
    this.originatorIdentification = originatorIdentification;
  }


  public IATBatchHeader standardEntryClassCode(@javax.annotation.Nonnull String standardEntryClassCode) {
    this.standardEntryClassCode = standardEntryClassCode;
    return this;
  }

  /**
   * StandardEntryClassCode for consumer and non consumer international payments is IAT. Identifies the payment type (product) found within an ACH batch using a 3-character code. The SEC Code pertains to all items within batch. Determines format of the detail records. Determines addenda records (required or optional PLUS one or up to 9,999 records). Determines rules to follow (return time frames). Some SEC codes require specific data in predetermined fields within the ACH record. 
   * @return standardEntryClassCode
   */
  @javax.annotation.Nonnull
  public String getStandardEntryClassCode() {
    return standardEntryClassCode;
  }

  public void setStandardEntryClassCode(@javax.annotation.Nonnull String standardEntryClassCode) {
    this.standardEntryClassCode = standardEntryClassCode;
  }


  public IATBatchHeader companyEntryDescription(@javax.annotation.Nullable String companyEntryDescription) {
    this.companyEntryDescription = companyEntryDescription;
    return this;
  }

  /**
   * A description of the entries contained in the batch The Originator establishes the value of this field to provide a description of the purpose of the entry to be displayed back to the receiver. For example, \&quot;GAS BILL,\&quot; \&quot;REG. SALARY,\&quot; \&quot;INS. PREM,\&quot; \&quot;SOC. SEC.,\&quot; \&quot;DTC,\&quot; \&quot;TRADE PAY,\&quot; \&quot;PURCHASE,\&quot; etc. This field must contain the word \&quot;REVERSAL\&quot; (left justified) when the batch contains reversing entries. This field must contain the word \&quot;RECLAIM\&quot; (left justified) when the batch contains reclamation entries. This field must contain the word \&quot;NONSETTLED\&quot; (left justified) when the batch contains entries which could not settle. 
   * @return companyEntryDescription
   */
  @javax.annotation.Nullable
  public String getCompanyEntryDescription() {
    return companyEntryDescription;
  }

  public void setCompanyEntryDescription(@javax.annotation.Nullable String companyEntryDescription) {
    this.companyEntryDescription = companyEntryDescription;
  }


  public IATBatchHeader isOOriginatingCurrencyCode(@javax.annotation.Nonnull String isOOriginatingCurrencyCode) {
    this.isOOriginatingCurrencyCode = isOOriginatingCurrencyCode;
    return this;
  }

  /**
   * Three-character code, as approved by the International Organization for Standardization (ISO), to identify the currency denomination in which the entry was first originated. If the source of funds is within the territorial jurisdiction of the U.S., enter &#39;USD&#39;, otherwise refer to International Organization for Standardization website for value: www.iso.org 
   * @return isOOriginatingCurrencyCode
   */
  @javax.annotation.Nonnull
  public String getIsOOriginatingCurrencyCode() {
    return isOOriginatingCurrencyCode;
  }

  public void setIsOOriginatingCurrencyCode(@javax.annotation.Nonnull String isOOriginatingCurrencyCode) {
    this.isOOriginatingCurrencyCode = isOOriginatingCurrencyCode;
  }


  public IATBatchHeader isODestinationCurrencyCode(@javax.annotation.Nonnull String isODestinationCurrencyCode) {
    this.isODestinationCurrencyCode = isODestinationCurrencyCode;
    return this;
  }

  /**
   * ISODestinationCurrencyCode is the three-character code, as approved by the International Organization for Standardization (ISO), to identify the currency denomination in which the entry will ultimately be settled. If the final destination of funds is within the territorial jurisdiction of the U.S., enter \&quot;USD\&quot;, otherwise refer to International Organization for Standardization website for value: www.iso.org 
   * @return isODestinationCurrencyCode
   */
  @javax.annotation.Nonnull
  public String getIsODestinationCurrencyCode() {
    return isODestinationCurrencyCode;
  }

  public void setIsODestinationCurrencyCode(@javax.annotation.Nonnull String isODestinationCurrencyCode) {
    this.isODestinationCurrencyCode = isODestinationCurrencyCode;
  }


  public IATBatchHeader effectiveEntryDate(@javax.annotation.Nullable String effectiveEntryDate) {
    this.effectiveEntryDate = effectiveEntryDate;
    return this;
  }

  /**
   * EffectiveEntryDate the date on which the entries are to settle. Format YYMMDD (Y&#x3D;Year, M&#x3D;Month, D&#x3D;Day) 
   * @return effectiveEntryDate
   */
  @javax.annotation.Nullable
  public String getEffectiveEntryDate() {
    return effectiveEntryDate;
  }

  public void setEffectiveEntryDate(@javax.annotation.Nullable String effectiveEntryDate) {
    this.effectiveEntryDate = effectiveEntryDate;
  }


  public IATBatchHeader originatorStatusCode(@javax.annotation.Nullable Integer originatorStatusCode) {
    this.originatorStatusCode = originatorStatusCode;
    return this;
  }

  /**
   * ODFI initiating the Entry. | 0 - ADV File prepared by an ACH Operator. | 1 - This code identifies the Originator as a depository financial institution. | 2 - This code identifies the Originator as a Federal Government entity or agency. 
   * @return originatorStatusCode
   */
  @javax.annotation.Nullable
  public Integer getOriginatorStatusCode() {
    return originatorStatusCode;
  }

  public void setOriginatorStatusCode(@javax.annotation.Nullable Integer originatorStatusCode) {
    this.originatorStatusCode = originatorStatusCode;
  }


  public IATBatchHeader odFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
    return this;
  }

  /**
   * First 8 digits of the originating DFI transit routing number. For Inbound IAT Entries, this field contains the routing number of the U.S. Gateway Operator.  For Outbound IAT Entries, this field contains the standard routing number, as assigned by Accuity, that identifies the U.S. ODFI initiating the Entry. (Format TTTTAAAA - T&#x3D;Federal Reserve Routing Symbol, A&#x3D;ABA Institution Identifier) 
   * @return odFIIdentification
   */
  @javax.annotation.Nonnull
  public String getOdFIIdentification() {
    return odFIIdentification;
  }

  public void setOdFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
  }


  public IATBatchHeader batchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
    return this;
  }

  /**
   * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record. 
   * @return batchNumber
   */
  @javax.annotation.Nonnull
  public Integer getBatchNumber() {
    return batchNumber;
  }

  public void setBatchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
  }


  public IATBatchHeader settlementDate(@javax.annotation.Nullable String settlementDate) {
    this.settlementDate = settlementDate;
    return this;
  }

  /**
   * The date the entries actually settled (this is inserted by the ACH operator)
   * @return settlementDate
   */
  @javax.annotation.Nullable
  public String getSettlementDate() {
    return settlementDate;
  }

  public void setSettlementDate(@javax.annotation.Nullable String settlementDate) {
    this.settlementDate = settlementDate;
  }


  public IATBatchHeader lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IATBatchHeader iaTBatchHeader = (IATBatchHeader) o;
    return Objects.equals(this.id, iaTBatchHeader.id) &&
        Objects.equals(this.serviceClassCode, iaTBatchHeader.serviceClassCode) &&
        Objects.equals(this.iaTIndicator, iaTBatchHeader.iaTIndicator) &&
        Objects.equals(this.foreignExchangeIndicator, iaTBatchHeader.foreignExchangeIndicator) &&
        Objects.equals(this.foreignExchangeReferenceIndicator, iaTBatchHeader.foreignExchangeReferenceIndicator) &&
        Objects.equals(this.foreignExchangeReference, iaTBatchHeader.foreignExchangeReference) &&
        Objects.equals(this.isODestinationCountryCode, iaTBatchHeader.isODestinationCountryCode) &&
        Objects.equals(this.originatorIdentification, iaTBatchHeader.originatorIdentification) &&
        Objects.equals(this.standardEntryClassCode, iaTBatchHeader.standardEntryClassCode) &&
        Objects.equals(this.companyEntryDescription, iaTBatchHeader.companyEntryDescription) &&
        Objects.equals(this.isOOriginatingCurrencyCode, iaTBatchHeader.isOOriginatingCurrencyCode) &&
        Objects.equals(this.isODestinationCurrencyCode, iaTBatchHeader.isODestinationCurrencyCode) &&
        Objects.equals(this.effectiveEntryDate, iaTBatchHeader.effectiveEntryDate) &&
        Objects.equals(this.originatorStatusCode, iaTBatchHeader.originatorStatusCode) &&
        Objects.equals(this.odFIIdentification, iaTBatchHeader.odFIIdentification) &&
        Objects.equals(this.batchNumber, iaTBatchHeader.batchNumber) &&
        Objects.equals(this.settlementDate, iaTBatchHeader.settlementDate) &&
        Objects.equals(this.lineNumber, iaTBatchHeader.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, serviceClassCode, iaTIndicator, foreignExchangeIndicator, foreignExchangeReferenceIndicator, foreignExchangeReference, isODestinationCountryCode, originatorIdentification, standardEntryClassCode, companyEntryDescription, isOOriginatingCurrencyCode, isODestinationCurrencyCode, effectiveEntryDate, originatorStatusCode, odFIIdentification, batchNumber, settlementDate, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IATBatchHeader {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    serviceClassCode: ").append(toIndentedString(serviceClassCode)).append("\n");
    sb.append("    iaTIndicator: ").append(toIndentedString(iaTIndicator)).append("\n");
    sb.append("    foreignExchangeIndicator: ").append(toIndentedString(foreignExchangeIndicator)).append("\n");
    sb.append("    foreignExchangeReferenceIndicator: ").append(toIndentedString(foreignExchangeReferenceIndicator)).append("\n");
    sb.append("    foreignExchangeReference: ").append(toIndentedString(foreignExchangeReference)).append("\n");
    sb.append("    isODestinationCountryCode: ").append(toIndentedString(isODestinationCountryCode)).append("\n");
    sb.append("    originatorIdentification: ").append(toIndentedString(originatorIdentification)).append("\n");
    sb.append("    standardEntryClassCode: ").append(toIndentedString(standardEntryClassCode)).append("\n");
    sb.append("    companyEntryDescription: ").append(toIndentedString(companyEntryDescription)).append("\n");
    sb.append("    isOOriginatingCurrencyCode: ").append(toIndentedString(isOOriginatingCurrencyCode)).append("\n");
    sb.append("    isODestinationCurrencyCode: ").append(toIndentedString(isODestinationCurrencyCode)).append("\n");
    sb.append("    effectiveEntryDate: ").append(toIndentedString(effectiveEntryDate)).append("\n");
    sb.append("    originatorStatusCode: ").append(toIndentedString(originatorStatusCode)).append("\n");
    sb.append("    odFIIdentification: ").append(toIndentedString(odFIIdentification)).append("\n");
    sb.append("    batchNumber: ").append(toIndentedString(batchNumber)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "serviceClassCode", "IATIndicator", "foreignExchangeIndicator", "foreignExchangeReferenceIndicator", "foreignExchangeReference", "ISODestinationCountryCode", "originatorIdentification", "standardEntryClassCode", "companyEntryDescription", "ISOOriginatingCurrencyCode", "ISODestinationCurrencyCode", "effectiveEntryDate", "originatorStatusCode", "ODFIIdentification", "batchNumber", "settlementDate", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("serviceClassCode", "foreignExchangeIndicator", "foreignExchangeReferenceIndicator", "foreignExchangeReference", "ISODestinationCountryCode", "originatorIdentification", "standardEntryClassCode", "ISOOriginatingCurrencyCode", "ISODestinationCurrencyCode", "ODFIIdentification", "batchNumber"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IATBatchHeader
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IATBatchHeader.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IATBatchHeader is not found in the empty JSON string", IATBatchHeader.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IATBatchHeader.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IATBatchHeader` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IATBatchHeader.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("IATIndicator") != null && !jsonObj.get("IATIndicator").isJsonNull()) && !jsonObj.get("IATIndicator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `IATIndicator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("IATIndicator").toString()));
      }
      if (!jsonObj.get("foreignExchangeIndicator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `foreignExchangeIndicator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("foreignExchangeIndicator").toString()));
      }
      if (!jsonObj.get("foreignExchangeReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `foreignExchangeReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("foreignExchangeReference").toString()));
      }
      if (!jsonObj.get("ISODestinationCountryCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ISODestinationCountryCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ISODestinationCountryCode").toString()));
      }
      if (!jsonObj.get("originatorIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originatorIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originatorIdentification").toString()));
      }
      if (!jsonObj.get("standardEntryClassCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `standardEntryClassCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("standardEntryClassCode").toString()));
      }
      if ((jsonObj.get("companyEntryDescription") != null && !jsonObj.get("companyEntryDescription").isJsonNull()) && !jsonObj.get("companyEntryDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyEntryDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyEntryDescription").toString()));
      }
      if (!jsonObj.get("ISOOriginatingCurrencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ISOOriginatingCurrencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ISOOriginatingCurrencyCode").toString()));
      }
      if (!jsonObj.get("ISODestinationCurrencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ISODestinationCurrencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ISODestinationCurrencyCode").toString()));
      }
      if ((jsonObj.get("effectiveEntryDate") != null && !jsonObj.get("effectiveEntryDate").isJsonNull()) && !jsonObj.get("effectiveEntryDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `effectiveEntryDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("effectiveEntryDate").toString()));
      }
      if (!jsonObj.get("ODFIIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ODFIIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ODFIIdentification").toString()));
      }
      if ((jsonObj.get("settlementDate") != null && !jsonObj.get("settlementDate").isJsonNull()) && !jsonObj.get("settlementDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `settlementDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("settlementDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IATBatchHeader.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IATBatchHeader' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IATBatchHeader> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IATBatchHeader.class));

       return (TypeAdapter<T>) new TypeAdapter<IATBatchHeader>() {
           @Override
           public void write(JsonWriter out, IATBatchHeader value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IATBatchHeader read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IATBatchHeader given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IATBatchHeader
   * @throws IOException if the JSON string is invalid with respect to IATBatchHeader
   */
  public static IATBatchHeader fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IATBatchHeader.class);
  }

  /**
   * Convert an instance of IATBatchHeader to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

