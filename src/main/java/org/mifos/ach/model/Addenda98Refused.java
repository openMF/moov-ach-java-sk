/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * Addenda98Refused
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class Addenda98Refused {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_TYPE_CODE = "typeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  @javax.annotation.Nonnull
  private String typeCode;

  public static final String SERIALIZED_NAME_REFUSED_CHANGE_CODE = "refusedChangeCode";
  @SerializedName(SERIALIZED_NAME_REFUSED_CHANGE_CODE)
  @javax.annotation.Nonnull
  private String refusedChangeCode;

  public static final String SERIALIZED_NAME_ORIGINAL_TRACE = "originalTrace";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_TRACE)
  @javax.annotation.Nonnull
  private String originalTrace;

  public static final String SERIALIZED_NAME_ORIGINAL_D_F_I = "originalDFI";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_D_F_I)
  @javax.annotation.Nonnull
  private String originalDFI;

  public static final String SERIALIZED_NAME_CORRECTED_DATA = "correctedData";
  @SerializedName(SERIALIZED_NAME_CORRECTED_DATA)
  @javax.annotation.Nonnull
  private String correctedData;

  public static final String SERIALIZED_NAME_CHANGE_CODE = "changeCode";
  @SerializedName(SERIALIZED_NAME_CHANGE_CODE)
  @javax.annotation.Nonnull
  private String changeCode;

  public static final String SERIALIZED_NAME_TRACE_SEQUENCE_NUMBER = "traceSequenceNumber";
  @SerializedName(SERIALIZED_NAME_TRACE_SEQUENCE_NUMBER)
  @javax.annotation.Nonnull
  private String traceSequenceNumber;

  public static final String SERIALIZED_NAME_TRACE_NUMBER = "traceNumber";
  @SerializedName(SERIALIZED_NAME_TRACE_NUMBER)
  @javax.annotation.Nonnull
  private String traceNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public Addenda98Refused() {
  }

  public Addenda98Refused id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Client-defined string used as a reference to this record.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public Addenda98Refused typeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * 98 - NACHA regulations
   * @return typeCode
   */
  @javax.annotation.Nonnull
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
  }


  public Addenda98Refused refusedChangeCode(@javax.annotation.Nonnull String refusedChangeCode) {
    this.refusedChangeCode = refusedChangeCode;
    return this;
  }

  /**
   * The code specifying why the Notification of Change is being refused.
   * @return refusedChangeCode
   */
  @javax.annotation.Nonnull
  public String getRefusedChangeCode() {
    return refusedChangeCode;
  }

  public void setRefusedChangeCode(@javax.annotation.Nonnull String refusedChangeCode) {
    this.refusedChangeCode = refusedChangeCode;
  }


  public Addenda98Refused originalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
    return this;
  }

  /**
   * OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification. The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI, in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization. 
   * @return originalTrace
   */
  @javax.annotation.Nonnull
  public String getOriginalTrace() {
    return originalTrace;
  }

  public void setOriginalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
  }


  public Addenda98Refused originalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
    return this;
  }

  /**
   * The Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
   * @return originalDFI
   */
  @javax.annotation.Nonnull
  public String getOriginalDFI() {
    return originalDFI;
  }

  public void setOriginalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
  }


  public Addenda98Refused correctedData(@javax.annotation.Nonnull String correctedData) {
    this.correctedData = correctedData;
    return this;
  }

  /**
   * Correct field value of what changeCode references
   * @return correctedData
   */
  @javax.annotation.Nonnull
  public String getCorrectedData() {
    return correctedData;
  }

  public void setCorrectedData(@javax.annotation.Nonnull String correctedData) {
    this.correctedData = correctedData;
  }


  public Addenda98Refused changeCode(@javax.annotation.Nonnull String changeCode) {
    this.changeCode = changeCode;
    return this;
  }

  /**
   * ChangeCode field contains a standard code used by an ACH Operator or RDFI to describe the reason for a change Entry.
   * @return changeCode
   */
  @javax.annotation.Nonnull
  public String getChangeCode() {
    return changeCode;
  }

  public void setChangeCode(@javax.annotation.Nonnull String changeCode) {
    this.changeCode = changeCode;
  }


  public Addenda98Refused traceSequenceNumber(@javax.annotation.Nonnull String traceSequenceNumber) {
    this.traceSequenceNumber = traceSequenceNumber;
    return this;
  }

  /**
   * The last seven digits of the TraceNumber in the original Notification of Change.
   * @return traceSequenceNumber
   */
  @javax.annotation.Nonnull
  public String getTraceSequenceNumber() {
    return traceSequenceNumber;
  }

  public void setTraceSequenceNumber(@javax.annotation.Nonnull String traceSequenceNumber) {
    this.traceSequenceNumber = traceSequenceNumber;
  }


  public Addenda98Refused traceNumber(@javax.annotation.Nonnull String traceNumber) {
    this.traceNumber = traceNumber;
    return this;
  }

  /**
   * Entry Detail Trace Number
   * @return traceNumber
   */
  @javax.annotation.Nonnull
  public String getTraceNumber() {
    return traceNumber;
  }

  public void setTraceNumber(@javax.annotation.Nonnull String traceNumber) {
    this.traceNumber = traceNumber;
  }


  public Addenda98Refused lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Addenda98Refused addenda98Refused = (Addenda98Refused) o;
    return Objects.equals(this.id, addenda98Refused.id) &&
        Objects.equals(this.typeCode, addenda98Refused.typeCode) &&
        Objects.equals(this.refusedChangeCode, addenda98Refused.refusedChangeCode) &&
        Objects.equals(this.originalTrace, addenda98Refused.originalTrace) &&
        Objects.equals(this.originalDFI, addenda98Refused.originalDFI) &&
        Objects.equals(this.correctedData, addenda98Refused.correctedData) &&
        Objects.equals(this.changeCode, addenda98Refused.changeCode) &&
        Objects.equals(this.traceSequenceNumber, addenda98Refused.traceSequenceNumber) &&
        Objects.equals(this.traceNumber, addenda98Refused.traceNumber) &&
        Objects.equals(this.lineNumber, addenda98Refused.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, typeCode, refusedChangeCode, originalTrace, originalDFI, correctedData, changeCode, traceSequenceNumber, traceNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Addenda98Refused {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    refusedChangeCode: ").append(toIndentedString(refusedChangeCode)).append("\n");
    sb.append("    originalTrace: ").append(toIndentedString(originalTrace)).append("\n");
    sb.append("    originalDFI: ").append(toIndentedString(originalDFI)).append("\n");
    sb.append("    correctedData: ").append(toIndentedString(correctedData)).append("\n");
    sb.append("    changeCode: ").append(toIndentedString(changeCode)).append("\n");
    sb.append("    traceSequenceNumber: ").append(toIndentedString(traceSequenceNumber)).append("\n");
    sb.append("    traceNumber: ").append(toIndentedString(traceNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "typeCode", "refusedChangeCode", "originalTrace", "originalDFI", "correctedData", "changeCode", "traceSequenceNumber", "traceNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("typeCode", "refusedChangeCode", "originalTrace", "originalDFI", "correctedData", "changeCode", "traceSequenceNumber", "traceNumber"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Addenda98Refused
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Addenda98Refused.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Addenda98Refused is not found in the empty JSON string", Addenda98Refused.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Addenda98Refused.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Addenda98Refused` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Addenda98Refused.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("typeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeCode").toString()));
      }
      if (!jsonObj.get("refusedChangeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `refusedChangeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("refusedChangeCode").toString()));
      }
      if (!jsonObj.get("originalTrace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalTrace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalTrace").toString()));
      }
      if (!jsonObj.get("originalDFI").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalDFI` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalDFI").toString()));
      }
      if (!jsonObj.get("correctedData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `correctedData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("correctedData").toString()));
      }
      if (!jsonObj.get("changeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `changeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("changeCode").toString()));
      }
      if (!jsonObj.get("traceSequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traceSequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traceSequenceNumber").toString()));
      }
      if (!jsonObj.get("traceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traceNumber").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Addenda98Refused.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Addenda98Refused' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Addenda98Refused> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Addenda98Refused.class));

       return (TypeAdapter<T>) new TypeAdapter<Addenda98Refused>() {
           @Override
           public void write(JsonWriter out, Addenda98Refused value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Addenda98Refused read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Addenda98Refused given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Addenda98Refused
   * @throws IOException if the JSON string is invalid with respect to Addenda98Refused
   */
  public static Addenda98Refused fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Addenda98Refused.class);
  }

  /**
   * Convert an instance of Addenda98Refused to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

