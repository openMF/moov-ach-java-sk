/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * ADVBatchControl
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class ADVBatchControl {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_SERVICE_CLASS_CODE = "serviceClassCode";
  @SerializedName(SERIALIZED_NAME_SERVICE_CLASS_CODE)
  @javax.annotation.Nonnull
  private Integer serviceClassCode;

  public static final String SERIALIZED_NAME_ENTRY_ADDENDA_COUNT = "entryAddendaCount";
  @SerializedName(SERIALIZED_NAME_ENTRY_ADDENDA_COUNT)
  @javax.annotation.Nonnull
  private Integer entryAddendaCount;

  public static final String SERIALIZED_NAME_ENTRY_HASH = "entryHash";
  @SerializedName(SERIALIZED_NAME_ENTRY_HASH)
  @javax.annotation.Nonnull
  private Long entryHash;

  public static final String SERIALIZED_NAME_TOTAL_DEBIT = "totalDebit";
  @SerializedName(SERIALIZED_NAME_TOTAL_DEBIT)
  @javax.annotation.Nonnull
  private Long totalDebit;

  public static final String SERIALIZED_NAME_TOTAL_CREDIT = "totalCredit";
  @SerializedName(SERIALIZED_NAME_TOTAL_CREDIT)
  @javax.annotation.Nonnull
  private Long totalCredit;

  public static final String SERIALIZED_NAME_ACH_OPERATOR_DATA = "achOperatorData";
  @SerializedName(SERIALIZED_NAME_ACH_OPERATOR_DATA)
  @javax.annotation.Nonnull
  private String achOperatorData;

  public static final String SERIALIZED_NAME_OD_F_I_IDENTIFICATION = "ODFIIdentification";
  @SerializedName(SERIALIZED_NAME_OD_F_I_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String odFIIdentification;

  public static final String SERIALIZED_NAME_BATCH_NUMBER = "batchNumber";
  @SerializedName(SERIALIZED_NAME_BATCH_NUMBER)
  @javax.annotation.Nonnull
  private Integer batchNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public ADVBatchControl() {
  }

  public ADVBatchControl id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Batch ID
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public ADVBatchControl serviceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
    return this;
  }

  /**
   * Same as ServiceClassCode in BatchHeader record
   * @return serviceClassCode
   */
  @javax.annotation.Nonnull
  public Integer getServiceClassCode() {
    return serviceClassCode;
  }

  public void setServiceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
  }


  public ADVBatchControl entryAddendaCount(@javax.annotation.Nonnull Integer entryAddendaCount) {
    this.entryAddendaCount = entryAddendaCount;
    return this;
  }

  /**
   * EntryAddendaCount is a tally of each Entry Detail Record and each Addenda Record processed, within either the batch or file as appropriate.
   * @return entryAddendaCount
   */
  @javax.annotation.Nonnull
  public Integer getEntryAddendaCount() {
    return entryAddendaCount;
  }

  public void setEntryAddendaCount(@javax.annotation.Nonnull Integer entryAddendaCount) {
    this.entryAddendaCount = entryAddendaCount;
  }


  public ADVBatchControl entryHash(@javax.annotation.Nonnull Long entryHash) {
    this.entryHash = entryHash;
    return this;
  }

  /**
   * Validate the Receiving DFI Identification in each Entry Detail Record is hashed to provide a check against inadvertent alteration of data contents due to hardware failure or program error. In this context the Entry Hash is the sum of the corresponding fields in the Entry Detail Records on the file. 
   * @return entryHash
   */
  @javax.annotation.Nonnull
  public Long getEntryHash() {
    return entryHash;
  }

  public void setEntryHash(@javax.annotation.Nonnull Long entryHash) {
    this.entryHash = entryHash;
  }


  public ADVBatchControl totalDebit(@javax.annotation.Nonnull Long totalDebit) {
    this.totalDebit = totalDebit;
    return this;
  }

  /**
   * Contains accumulated Entry debit totals within the batch.
   * @return totalDebit
   */
  @javax.annotation.Nonnull
  public Long getTotalDebit() {
    return totalDebit;
  }

  public void setTotalDebit(@javax.annotation.Nonnull Long totalDebit) {
    this.totalDebit = totalDebit;
  }


  public ADVBatchControl totalCredit(@javax.annotation.Nonnull Long totalCredit) {
    this.totalCredit = totalCredit;
    return this;
  }

  /**
   * Contains accumulated Entry credit totals within the batch.
   * @return totalCredit
   */
  @javax.annotation.Nonnull
  public Long getTotalCredit() {
    return totalCredit;
  }

  public void setTotalCredit(@javax.annotation.Nonnull Long totalCredit) {
    this.totalCredit = totalCredit;
  }


  public ADVBatchControl achOperatorData(@javax.annotation.Nonnull String achOperatorData) {
    this.achOperatorData = achOperatorData;
    return this;
  }

  /**
   * Alphanumeric code used to identify an ACH Operator
   * @return achOperatorData
   */
  @javax.annotation.Nonnull
  public String getAchOperatorData() {
    return achOperatorData;
  }

  public void setAchOperatorData(@javax.annotation.Nonnull String achOperatorData) {
    this.achOperatorData = achOperatorData;
  }


  public ADVBatchControl odFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
    return this;
  }

  /**
   * The routing number is used to identify the DFI originating entries within a given branch.
   * @return odFIIdentification
   */
  @javax.annotation.Nonnull
  public String getOdFIIdentification() {
    return odFIIdentification;
  }

  public void setOdFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
  }


  public ADVBatchControl batchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
    return this;
  }

  /**
   * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record.
   * @return batchNumber
   */
  @javax.annotation.Nonnull
  public Integer getBatchNumber() {
    return batchNumber;
  }

  public void setBatchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
  }


  public ADVBatchControl lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ADVBatchControl adVBatchControl = (ADVBatchControl) o;
    return Objects.equals(this.id, adVBatchControl.id) &&
        Objects.equals(this.serviceClassCode, adVBatchControl.serviceClassCode) &&
        Objects.equals(this.entryAddendaCount, adVBatchControl.entryAddendaCount) &&
        Objects.equals(this.entryHash, adVBatchControl.entryHash) &&
        Objects.equals(this.totalDebit, adVBatchControl.totalDebit) &&
        Objects.equals(this.totalCredit, adVBatchControl.totalCredit) &&
        Objects.equals(this.achOperatorData, adVBatchControl.achOperatorData) &&
        Objects.equals(this.odFIIdentification, adVBatchControl.odFIIdentification) &&
        Objects.equals(this.batchNumber, adVBatchControl.batchNumber) &&
        Objects.equals(this.lineNumber, adVBatchControl.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, serviceClassCode, entryAddendaCount, entryHash, totalDebit, totalCredit, achOperatorData, odFIIdentification, batchNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ADVBatchControl {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    serviceClassCode: ").append(toIndentedString(serviceClassCode)).append("\n");
    sb.append("    entryAddendaCount: ").append(toIndentedString(entryAddendaCount)).append("\n");
    sb.append("    entryHash: ").append(toIndentedString(entryHash)).append("\n");
    sb.append("    totalDebit: ").append(toIndentedString(totalDebit)).append("\n");
    sb.append("    totalCredit: ").append(toIndentedString(totalCredit)).append("\n");
    sb.append("    achOperatorData: ").append(toIndentedString(achOperatorData)).append("\n");
    sb.append("    odFIIdentification: ").append(toIndentedString(odFIIdentification)).append("\n");
    sb.append("    batchNumber: ").append(toIndentedString(batchNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "serviceClassCode", "entryAddendaCount", "entryHash", "totalDebit", "totalCredit", "achOperatorData", "ODFIIdentification", "batchNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("serviceClassCode", "entryAddendaCount", "entryHash", "totalDebit", "totalCredit", "achOperatorData", "ODFIIdentification", "batchNumber"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ADVBatchControl
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ADVBatchControl.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ADVBatchControl is not found in the empty JSON string", ADVBatchControl.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ADVBatchControl.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ADVBatchControl` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ADVBatchControl.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("achOperatorData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `achOperatorData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("achOperatorData").toString()));
      }
      if (!jsonObj.get("ODFIIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ODFIIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ODFIIdentification").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ADVBatchControl.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ADVBatchControl' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ADVBatchControl> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ADVBatchControl.class));

       return (TypeAdapter<T>) new TypeAdapter<ADVBatchControl>() {
           @Override
           public void write(JsonWriter out, ADVBatchControl value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ADVBatchControl read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ADVBatchControl given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ADVBatchControl
   * @throws IOException if the JSON string is invalid with respect to ADVBatchControl
   */
  public static ADVBatchControl fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ADVBatchControl.class);
  }

  /**
   * Convert an instance of ADVBatchControl to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

