/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * Addenda98
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class Addenda98 {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_TYPE_CODE = "typeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  @javax.annotation.Nonnull
  private String typeCode;

  public static final String SERIALIZED_NAME_CHANGE_CODE = "changeCode";
  @SerializedName(SERIALIZED_NAME_CHANGE_CODE)
  @javax.annotation.Nonnull
  private String changeCode;

  public static final String SERIALIZED_NAME_ORIGINAL_TRACE = "originalTrace";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_TRACE)
  @javax.annotation.Nonnull
  private String originalTrace;

  public static final String SERIALIZED_NAME_ORIGINAL_D_F_I = "originalDFI";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_D_F_I)
  @javax.annotation.Nonnull
  private String originalDFI;

  public static final String SERIALIZED_NAME_CORRECTED_DATA = "correctedData";
  @SerializedName(SERIALIZED_NAME_CORRECTED_DATA)
  @javax.annotation.Nonnull
  private String correctedData;

  public static final String SERIALIZED_NAME_TRACE_NUMBER = "traceNumber";
  @SerializedName(SERIALIZED_NAME_TRACE_NUMBER)
  @javax.annotation.Nullable
  private String traceNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public Addenda98() {
  }

  public Addenda98 id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Client-defined string used as a reference to this record.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public Addenda98 typeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * 98 - NACHA regulations
   * @return typeCode
   */
  @javax.annotation.Nonnull
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
  }


  public Addenda98 changeCode(@javax.annotation.Nonnull String changeCode) {
    this.changeCode = changeCode;
    return this;
  }

  /**
   * ChangeCode field contains a standard code used by an ACH Operator or RDFI to describe the reason for a change Entry.
   * @return changeCode
   */
  @javax.annotation.Nonnull
  public String getChangeCode() {
    return changeCode;
  }

  public void setChangeCode(@javax.annotation.Nonnull String changeCode) {
    this.changeCode = changeCode;
  }


  public Addenda98 originalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
    return this;
  }

  /**
   * OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification. The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI, in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization. 
   * @return originalTrace
   */
  @javax.annotation.Nonnull
  public String getOriginalTrace() {
    return originalTrace;
  }

  public void setOriginalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
  }


  public Addenda98 originalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
    return this;
  }

  /**
   * The Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
   * @return originalDFI
   */
  @javax.annotation.Nonnull
  public String getOriginalDFI() {
    return originalDFI;
  }

  public void setOriginalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
  }


  public Addenda98 correctedData(@javax.annotation.Nonnull String correctedData) {
    this.correctedData = correctedData;
    return this;
  }

  /**
   * Correct field value of what changeCode references
   * @return correctedData
   */
  @javax.annotation.Nonnull
  public String getCorrectedData() {
    return correctedData;
  }

  public void setCorrectedData(@javax.annotation.Nonnull String correctedData) {
    this.correctedData = correctedData;
  }


  public Addenda98 traceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
    return this;
  }

  /**
   * Entry Detail Trace Number
   * @return traceNumber
   */
  @javax.annotation.Nullable
  public String getTraceNumber() {
    return traceNumber;
  }

  public void setTraceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
  }


  public Addenda98 lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Addenda98 addenda98 = (Addenda98) o;
    return Objects.equals(this.id, addenda98.id) &&
        Objects.equals(this.typeCode, addenda98.typeCode) &&
        Objects.equals(this.changeCode, addenda98.changeCode) &&
        Objects.equals(this.originalTrace, addenda98.originalTrace) &&
        Objects.equals(this.originalDFI, addenda98.originalDFI) &&
        Objects.equals(this.correctedData, addenda98.correctedData) &&
        Objects.equals(this.traceNumber, addenda98.traceNumber) &&
        Objects.equals(this.lineNumber, addenda98.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, typeCode, changeCode, originalTrace, originalDFI, correctedData, traceNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Addenda98 {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    changeCode: ").append(toIndentedString(changeCode)).append("\n");
    sb.append("    originalTrace: ").append(toIndentedString(originalTrace)).append("\n");
    sb.append("    originalDFI: ").append(toIndentedString(originalDFI)).append("\n");
    sb.append("    correctedData: ").append(toIndentedString(correctedData)).append("\n");
    sb.append("    traceNumber: ").append(toIndentedString(traceNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "typeCode", "changeCode", "originalTrace", "originalDFI", "correctedData", "traceNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("typeCode", "changeCode", "originalTrace", "originalDFI", "correctedData"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Addenda98
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Addenda98.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Addenda98 is not found in the empty JSON string", Addenda98.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Addenda98.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Addenda98` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Addenda98.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("typeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeCode").toString()));
      }
      if (!jsonObj.get("changeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `changeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("changeCode").toString()));
      }
      if (!jsonObj.get("originalTrace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalTrace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalTrace").toString()));
      }
      if (!jsonObj.get("originalDFI").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalDFI` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalDFI").toString()));
      }
      if (!jsonObj.get("correctedData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `correctedData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("correctedData").toString()));
      }
      if ((jsonObj.get("traceNumber") != null && !jsonObj.get("traceNumber").isJsonNull()) && !jsonObj.get("traceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traceNumber").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Addenda98.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Addenda98' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Addenda98> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Addenda98.class));

       return (TypeAdapter<T>) new TypeAdapter<Addenda98>() {
           @Override
           public void write(JsonWriter out, Addenda98 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Addenda98 read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Addenda98 given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Addenda98
   * @throws IOException if the JSON string is invalid with respect to Addenda98
   */
  public static Addenda98 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Addenda98.class);
  }

  /**
   * Convert an instance of Addenda98 to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

