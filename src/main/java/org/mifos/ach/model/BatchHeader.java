/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * BatchHeader
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class BatchHeader {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_SERVICE_CLASS_CODE = "serviceClassCode";
  @SerializedName(SERIALIZED_NAME_SERVICE_CLASS_CODE)
  @javax.annotation.Nonnull
  private Integer serviceClassCode;

  public static final String SERIALIZED_NAME_COMPANY_NAME = "companyName";
  @SerializedName(SERIALIZED_NAME_COMPANY_NAME)
  @javax.annotation.Nonnull
  private String companyName;

  public static final String SERIALIZED_NAME_COMPANY_DISCRETIONARY_DATA = "companyDiscretionaryData";
  @SerializedName(SERIALIZED_NAME_COMPANY_DISCRETIONARY_DATA)
  @javax.annotation.Nullable
  private String companyDiscretionaryData;

  public static final String SERIALIZED_NAME_COMPANY_IDENTIFICATION = "companyIdentification";
  @SerializedName(SERIALIZED_NAME_COMPANY_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String companyIdentification;

  public static final String SERIALIZED_NAME_STANDARD_ENTRY_CLASS_CODE = "standardEntryClassCode";
  @SerializedName(SERIALIZED_NAME_STANDARD_ENTRY_CLASS_CODE)
  @javax.annotation.Nonnull
  private String standardEntryClassCode;

  public static final String SERIALIZED_NAME_COMPANY_ENTRY_DESCRIPTION = "companyEntryDescription";
  @SerializedName(SERIALIZED_NAME_COMPANY_ENTRY_DESCRIPTION)
  @javax.annotation.Nonnull
  private String companyEntryDescription;

  public static final String SERIALIZED_NAME_COMPANY_DESCRIPTIVE_DATE = "companyDescriptiveDate";
  @SerializedName(SERIALIZED_NAME_COMPANY_DESCRIPTIVE_DATE)
  @javax.annotation.Nullable
  private String companyDescriptiveDate;

  public static final String SERIALIZED_NAME_EFFECTIVE_ENTRY_DATE = "effectiveEntryDate";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_ENTRY_DATE)
  @javax.annotation.Nullable
  private String effectiveEntryDate;

  public static final String SERIALIZED_NAME_ORIGINATOR_STATUS_CODE = "originatorStatusCode";
  @SerializedName(SERIALIZED_NAME_ORIGINATOR_STATUS_CODE)
  @javax.annotation.Nullable
  private Integer originatorStatusCode;

  public static final String SERIALIZED_NAME_OD_F_I_IDENTIFICATION = "ODFIIdentification";
  @SerializedName(SERIALIZED_NAME_OD_F_I_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String odFIIdentification;

  public static final String SERIALIZED_NAME_BATCH_NUMBER = "batchNumber";
  @SerializedName(SERIALIZED_NAME_BATCH_NUMBER)
  @javax.annotation.Nullable
  private Integer batchNumber;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  @javax.annotation.Nullable
  private String settlementDate;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public BatchHeader() {
  }

  public BatchHeader id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * A client-defined ID used as a reference to this batch
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public BatchHeader serviceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
    return this;
  }

  /**
   * Service Class Code - Mixed Debits and Credits &#39;200&#39;, ACH Credits Only &#39;220&#39;, or ACH Debits Only &#39;225&#39;
   * @return serviceClassCode
   */
  @javax.annotation.Nonnull
  public Integer getServiceClassCode() {
    return serviceClassCode;
  }

  public void setServiceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
  }


  public BatchHeader companyName(@javax.annotation.Nonnull String companyName) {
    this.companyName = companyName;
    return this;
  }

  /**
   * Company originating the entries in the batch
   * @return companyName
   */
  @javax.annotation.Nonnull
  public String getCompanyName() {
    return companyName;
  }

  public void setCompanyName(@javax.annotation.Nonnull String companyName) {
    this.companyName = companyName;
  }


  public BatchHeader companyDiscretionaryData(@javax.annotation.Nullable String companyDiscretionaryData) {
    this.companyDiscretionaryData = companyDiscretionaryData;
    return this;
  }

  /**
   * The 9 digit FEIN number (proceeded by a predetermined alpha or numeric character) of the entity in the company name field
   * @return companyDiscretionaryData
   */
  @javax.annotation.Nullable
  public String getCompanyDiscretionaryData() {
    return companyDiscretionaryData;
  }

  public void setCompanyDiscretionaryData(@javax.annotation.Nullable String companyDiscretionaryData) {
    this.companyDiscretionaryData = companyDiscretionaryData;
  }


  public BatchHeader companyIdentification(@javax.annotation.Nonnull String companyIdentification) {
    this.companyIdentification = companyIdentification;
    return this;
  }

  /**
   * Alphanumeric code used to identify an Originator. The Company Identification Field must be included on all prenotification records and on each entry initiated pursuant to such prenotification. The Company ID may begin with the ANSI one-digit Identification Code Designator (ICD), followed by the identification number. Possible ICDs are the IRS Employer Identification Number (EIN) \&quot;1\&quot;, Data Universal Numbering Systems (DUNS) \&quot;3\&quot;, or User Assigned Number \&quot;9\&quot;. 
   * @return companyIdentification
   */
  @javax.annotation.Nonnull
  public String getCompanyIdentification() {
    return companyIdentification;
  }

  public void setCompanyIdentification(@javax.annotation.Nonnull String companyIdentification) {
    this.companyIdentification = companyIdentification;
  }


  public BatchHeader standardEntryClassCode(@javax.annotation.Nonnull String standardEntryClassCode) {
    this.standardEntryClassCode = standardEntryClassCode;
    return this;
  }

  /**
   * Identifies the payment type (product) found within an ACH batch using a 3-character code.
   * @return standardEntryClassCode
   */
  @javax.annotation.Nonnull
  public String getStandardEntryClassCode() {
    return standardEntryClassCode;
  }

  public void setStandardEntryClassCode(@javax.annotation.Nonnull String standardEntryClassCode) {
    this.standardEntryClassCode = standardEntryClassCode;
  }


  public BatchHeader companyEntryDescription(@javax.annotation.Nonnull String companyEntryDescription) {
    this.companyEntryDescription = companyEntryDescription;
    return this;
  }

  /**
   * A description of the entries contained in the batch. The Originator establishes the value of this field to provide a description of the purpose of the entry to be displayed back to the receiver. For example, \&quot;GAS BILL,\&quot; \&quot;REG. SALARY,\&quot; \&quot;INS. PREM,\&quot;, \&quot;SOC. SEC.,\&quot; \&quot;DTC,\&quot; \&quot;TRADE PAY,\&quot; \&quot;PURCHASE,\&quot; etc. This field must contain the word \&quot;REVERSAL\&quot; (left justified) when the batch contains reversing entries. This field must contain the word \&quot;RECLAIM\&quot; (left justified) when the batch contains reclamation entries. This field must contain the word \&quot;NONSETTLED\&quot; (left justified) when the batch contains entries which could not settle. 
   * @return companyEntryDescription
   */
  @javax.annotation.Nonnull
  public String getCompanyEntryDescription() {
    return companyEntryDescription;
  }

  public void setCompanyEntryDescription(@javax.annotation.Nonnull String companyEntryDescription) {
    this.companyEntryDescription = companyEntryDescription;
  }


  public BatchHeader companyDescriptiveDate(@javax.annotation.Nullable String companyDescriptiveDate) {
    this.companyDescriptiveDate = companyDescriptiveDate;
    return this;
  }

  /**
   * The Originator establishes this field as the date it would like to see displayed to the receiver for descriptive purposes. This field is never used to control timing of any computer or manual operation. It is solely for descriptive purposes. The RDFI should not assume any specific format. 
   * @return companyDescriptiveDate
   */
  @javax.annotation.Nullable
  public String getCompanyDescriptiveDate() {
    return companyDescriptiveDate;
  }

  public void setCompanyDescriptiveDate(@javax.annotation.Nullable String companyDescriptiveDate) {
    this.companyDescriptiveDate = companyDescriptiveDate;
  }


  public BatchHeader effectiveEntryDate(@javax.annotation.Nullable String effectiveEntryDate) {
    this.effectiveEntryDate = effectiveEntryDate;
    return this;
  }

  /**
   * Date on which the entries are to settle. (Format YYMMDD - Y&#x3D;Year, M&#x3D;Month, D&#x3D;Day)
   * @return effectiveEntryDate
   */
  @javax.annotation.Nullable
  public String getEffectiveEntryDate() {
    return effectiveEntryDate;
  }

  public void setEffectiveEntryDate(@javax.annotation.Nullable String effectiveEntryDate) {
    this.effectiveEntryDate = effectiveEntryDate;
  }


  public BatchHeader originatorStatusCode(@javax.annotation.Nullable Integer originatorStatusCode) {
    this.originatorStatusCode = originatorStatusCode;
    return this;
  }

  /**
   * ODFI initiating the Entry. | 0 - ADV File prepared by an ACH Operator. | 1 - This code identifies the Originator as a depository financial institution. | 2 - This code identifies the Originator as a Federal Government entity or agency. 
   * @return originatorStatusCode
   */
  @javax.annotation.Nullable
  public Integer getOriginatorStatusCode() {
    return originatorStatusCode;
  }

  public void setOriginatorStatusCode(@javax.annotation.Nullable Integer originatorStatusCode) {
    this.originatorStatusCode = originatorStatusCode;
  }


  public BatchHeader odFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
    return this;
  }

  /**
   * First 8 digits of the originating DFI transit routing number
   * @return odFIIdentification
   */
  @javax.annotation.Nonnull
  public String getOdFIIdentification() {
    return odFIIdentification;
  }

  public void setOdFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
  }


  public BatchHeader batchNumber(@javax.annotation.Nullable Integer batchNumber) {
    this.batchNumber = batchNumber;
    return this;
  }

  /**
   * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record. 
   * @return batchNumber
   */
  @javax.annotation.Nullable
  public Integer getBatchNumber() {
    return batchNumber;
  }

  public void setBatchNumber(@javax.annotation.Nullable Integer batchNumber) {
    this.batchNumber = batchNumber;
  }


  public BatchHeader settlementDate(@javax.annotation.Nullable String settlementDate) {
    this.settlementDate = settlementDate;
    return this;
  }

  /**
   * The date the entries actually settled (this is inserted by the ACH operator)
   * @return settlementDate
   */
  @javax.annotation.Nullable
  public String getSettlementDate() {
    return settlementDate;
  }

  public void setSettlementDate(@javax.annotation.Nullable String settlementDate) {
    this.settlementDate = settlementDate;
  }


  public BatchHeader lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchHeader batchHeader = (BatchHeader) o;
    return Objects.equals(this.id, batchHeader.id) &&
        Objects.equals(this.serviceClassCode, batchHeader.serviceClassCode) &&
        Objects.equals(this.companyName, batchHeader.companyName) &&
        Objects.equals(this.companyDiscretionaryData, batchHeader.companyDiscretionaryData) &&
        Objects.equals(this.companyIdentification, batchHeader.companyIdentification) &&
        Objects.equals(this.standardEntryClassCode, batchHeader.standardEntryClassCode) &&
        Objects.equals(this.companyEntryDescription, batchHeader.companyEntryDescription) &&
        Objects.equals(this.companyDescriptiveDate, batchHeader.companyDescriptiveDate) &&
        Objects.equals(this.effectiveEntryDate, batchHeader.effectiveEntryDate) &&
        Objects.equals(this.originatorStatusCode, batchHeader.originatorStatusCode) &&
        Objects.equals(this.odFIIdentification, batchHeader.odFIIdentification) &&
        Objects.equals(this.batchNumber, batchHeader.batchNumber) &&
        Objects.equals(this.settlementDate, batchHeader.settlementDate) &&
        Objects.equals(this.lineNumber, batchHeader.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, serviceClassCode, companyName, companyDiscretionaryData, companyIdentification, standardEntryClassCode, companyEntryDescription, companyDescriptiveDate, effectiveEntryDate, originatorStatusCode, odFIIdentification, batchNumber, settlementDate, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchHeader {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    serviceClassCode: ").append(toIndentedString(serviceClassCode)).append("\n");
    sb.append("    companyName: ").append(toIndentedString(companyName)).append("\n");
    sb.append("    companyDiscretionaryData: ").append(toIndentedString(companyDiscretionaryData)).append("\n");
    sb.append("    companyIdentification: ").append(toIndentedString(companyIdentification)).append("\n");
    sb.append("    standardEntryClassCode: ").append(toIndentedString(standardEntryClassCode)).append("\n");
    sb.append("    companyEntryDescription: ").append(toIndentedString(companyEntryDescription)).append("\n");
    sb.append("    companyDescriptiveDate: ").append(toIndentedString(companyDescriptiveDate)).append("\n");
    sb.append("    effectiveEntryDate: ").append(toIndentedString(effectiveEntryDate)).append("\n");
    sb.append("    originatorStatusCode: ").append(toIndentedString(originatorStatusCode)).append("\n");
    sb.append("    odFIIdentification: ").append(toIndentedString(odFIIdentification)).append("\n");
    sb.append("    batchNumber: ").append(toIndentedString(batchNumber)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "serviceClassCode", "companyName", "companyDiscretionaryData", "companyIdentification", "standardEntryClassCode", "companyEntryDescription", "companyDescriptiveDate", "effectiveEntryDate", "originatorStatusCode", "ODFIIdentification", "batchNumber", "settlementDate", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("serviceClassCode", "companyName", "companyIdentification", "standardEntryClassCode", "companyEntryDescription", "ODFIIdentification"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchHeader
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchHeader.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchHeader is not found in the empty JSON string", BatchHeader.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchHeader.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchHeader` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : BatchHeader.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("companyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyName").toString()));
      }
      if ((jsonObj.get("companyDiscretionaryData") != null && !jsonObj.get("companyDiscretionaryData").isJsonNull()) && !jsonObj.get("companyDiscretionaryData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyDiscretionaryData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyDiscretionaryData").toString()));
      }
      if (!jsonObj.get("companyIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyIdentification").toString()));
      }
      if (!jsonObj.get("standardEntryClassCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `standardEntryClassCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("standardEntryClassCode").toString()));
      }
      if (!jsonObj.get("companyEntryDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyEntryDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyEntryDescription").toString()));
      }
      if ((jsonObj.get("companyDescriptiveDate") != null && !jsonObj.get("companyDescriptiveDate").isJsonNull()) && !jsonObj.get("companyDescriptiveDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyDescriptiveDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyDescriptiveDate").toString()));
      }
      if ((jsonObj.get("effectiveEntryDate") != null && !jsonObj.get("effectiveEntryDate").isJsonNull()) && !jsonObj.get("effectiveEntryDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `effectiveEntryDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("effectiveEntryDate").toString()));
      }
      if (!jsonObj.get("ODFIIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ODFIIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ODFIIdentification").toString()));
      }
      if ((jsonObj.get("settlementDate") != null && !jsonObj.get("settlementDate").isJsonNull()) && !jsonObj.get("settlementDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `settlementDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("settlementDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchHeader.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchHeader' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchHeader> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchHeader.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchHeader>() {
           @Override
           public void write(JsonWriter out, BatchHeader value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchHeader read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchHeader given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchHeader
   * @throws IOException if the JSON string is invalid with respect to BatchHeader
   */
  public static BatchHeader fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchHeader.class);
  }

  /**
   * Convert an instance of BatchHeader to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

