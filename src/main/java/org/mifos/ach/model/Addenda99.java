/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * Addenda99
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class Addenda99 {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_TYPE_CODE = "typeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  @javax.annotation.Nonnull
  private String typeCode;

  public static final String SERIALIZED_NAME_RETURN_CODE = "returnCode";
  @SerializedName(SERIALIZED_NAME_RETURN_CODE)
  @javax.annotation.Nonnull
  private String returnCode;

  public static final String SERIALIZED_NAME_ORIGINAL_TRACE = "originalTrace";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_TRACE)
  @javax.annotation.Nonnull
  private String originalTrace;

  public static final String SERIALIZED_NAME_DATE_OF_DEATH = "dateOfDeath";
  @SerializedName(SERIALIZED_NAME_DATE_OF_DEATH)
  @javax.annotation.Nonnull
  private String dateOfDeath;

  public static final String SERIALIZED_NAME_ORIGINAL_D_F_I = "originalDFI";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_D_F_I)
  @javax.annotation.Nonnull
  private String originalDFI;

  public static final String SERIALIZED_NAME_ADDENDA_INFORMATION = "addendaInformation";
  @SerializedName(SERIALIZED_NAME_ADDENDA_INFORMATION)
  @javax.annotation.Nullable
  private String addendaInformation;

  public static final String SERIALIZED_NAME_TRACE_NUMBER = "traceNumber";
  @SerializedName(SERIALIZED_NAME_TRACE_NUMBER)
  @javax.annotation.Nullable
  private String traceNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public Addenda99() {
  }

  public Addenda99 id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Client-defined string used as a reference to this record.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public Addenda99 typeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * 99 - NACHA regulations
   * @return typeCode
   */
  @javax.annotation.Nonnull
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(@javax.annotation.Nonnull String typeCode) {
    this.typeCode = typeCode;
  }


  public Addenda99 returnCode(@javax.annotation.Nonnull String returnCode) {
    this.returnCode = returnCode;
    return this;
  }

  /**
   * Standard code used by an ACH Operator or RDFI to describe the reason for returning an Entry.
   * @return returnCode
   */
  @javax.annotation.Nonnull
  public String getReturnCode() {
    return returnCode;
  }

  public void setReturnCode(@javax.annotation.Nonnull String returnCode) {
    this.returnCode = returnCode;
  }


  public Addenda99 originalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
    return this;
  }

  /**
   * OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification. The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI, in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization. 
   * @return originalTrace
   */
  @javax.annotation.Nonnull
  public String getOriginalTrace() {
    return originalTrace;
  }

  public void setOriginalTrace(@javax.annotation.Nonnull String originalTrace) {
    this.originalTrace = originalTrace;
  }


  public Addenda99 dateOfDeath(@javax.annotation.Nonnull String dateOfDeath) {
    this.dateOfDeath = dateOfDeath;
    return this;
  }

  /**
   * The field date of death is to be supplied on Entries being returned for reason of death (return reason codes R14 and R15). (Format YYMMDD - Y&#x3D;Year, M&#x3D;Month, D&#x3D;Day)
   * @return dateOfDeath
   */
  @javax.annotation.Nonnull
  public String getDateOfDeath() {
    return dateOfDeath;
  }

  public void setDateOfDeath(@javax.annotation.Nonnull String dateOfDeath) {
    this.dateOfDeath = dateOfDeath;
  }


  public Addenda99 originalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
    return this;
  }

  /**
   * Contains the Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
   * @return originalDFI
   */
  @javax.annotation.Nonnull
  public String getOriginalDFI() {
    return originalDFI;
  }

  public void setOriginalDFI(@javax.annotation.Nonnull String originalDFI) {
    this.originalDFI = originalDFI;
  }


  public Addenda99 addendaInformation(@javax.annotation.Nullable String addendaInformation) {
    this.addendaInformation = addendaInformation;
    return this;
  }

  /**
   * Information related to the return
   * @return addendaInformation
   */
  @javax.annotation.Nullable
  public String getAddendaInformation() {
    return addendaInformation;
  }

  public void setAddendaInformation(@javax.annotation.Nullable String addendaInformation) {
    this.addendaInformation = addendaInformation;
  }


  public Addenda99 traceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
    return this;
  }

  /**
   * Matches the Entry Detail Trace Number of the entry being returned.
   * @return traceNumber
   */
  @javax.annotation.Nullable
  public String getTraceNumber() {
    return traceNumber;
  }

  public void setTraceNumber(@javax.annotation.Nullable String traceNumber) {
    this.traceNumber = traceNumber;
  }


  public Addenda99 lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Addenda99 addenda99 = (Addenda99) o;
    return Objects.equals(this.id, addenda99.id) &&
        Objects.equals(this.typeCode, addenda99.typeCode) &&
        Objects.equals(this.returnCode, addenda99.returnCode) &&
        Objects.equals(this.originalTrace, addenda99.originalTrace) &&
        Objects.equals(this.dateOfDeath, addenda99.dateOfDeath) &&
        Objects.equals(this.originalDFI, addenda99.originalDFI) &&
        Objects.equals(this.addendaInformation, addenda99.addendaInformation) &&
        Objects.equals(this.traceNumber, addenda99.traceNumber) &&
        Objects.equals(this.lineNumber, addenda99.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, typeCode, returnCode, originalTrace, dateOfDeath, originalDFI, addendaInformation, traceNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Addenda99 {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    returnCode: ").append(toIndentedString(returnCode)).append("\n");
    sb.append("    originalTrace: ").append(toIndentedString(originalTrace)).append("\n");
    sb.append("    dateOfDeath: ").append(toIndentedString(dateOfDeath)).append("\n");
    sb.append("    originalDFI: ").append(toIndentedString(originalDFI)).append("\n");
    sb.append("    addendaInformation: ").append(toIndentedString(addendaInformation)).append("\n");
    sb.append("    traceNumber: ").append(toIndentedString(traceNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "typeCode", "returnCode", "originalTrace", "dateOfDeath", "originalDFI", "addendaInformation", "traceNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("typeCode", "returnCode", "originalTrace", "dateOfDeath", "originalDFI"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Addenda99
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Addenda99.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Addenda99 is not found in the empty JSON string", Addenda99.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Addenda99.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Addenda99` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Addenda99.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("typeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeCode").toString()));
      }
      if (!jsonObj.get("returnCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `returnCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("returnCode").toString()));
      }
      if (!jsonObj.get("originalTrace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalTrace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalTrace").toString()));
      }
      if (!jsonObj.get("dateOfDeath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dateOfDeath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dateOfDeath").toString()));
      }
      if (!jsonObj.get("originalDFI").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalDFI` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalDFI").toString()));
      }
      if ((jsonObj.get("addendaInformation") != null && !jsonObj.get("addendaInformation").isJsonNull()) && !jsonObj.get("addendaInformation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `addendaInformation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("addendaInformation").toString()));
      }
      if ((jsonObj.get("traceNumber") != null && !jsonObj.get("traceNumber").isJsonNull()) && !jsonObj.get("traceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traceNumber").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Addenda99.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Addenda99' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Addenda99> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Addenda99.class));

       return (TypeAdapter<T>) new TypeAdapter<Addenda99>() {
           @Override
           public void write(JsonWriter out, Addenda99 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Addenda99 read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Addenda99 given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Addenda99
   * @throws IOException if the JSON string is invalid with respect to Addenda99
   */
  public static Addenda99 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Addenda99.class);
  }

  /**
   * Convert an instance of Addenda99 to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

