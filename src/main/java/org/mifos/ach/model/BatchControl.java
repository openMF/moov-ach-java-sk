/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mifos.ach.JSON;

/**
 * BatchControl
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T08:19:26.833252621Z[Etc/UTC]", comments = "Generator version: 7.16.0-SNAPSHOT")
public class BatchControl {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_SERVICE_CLASS_CODE = "serviceClassCode";
  @SerializedName(SERIALIZED_NAME_SERVICE_CLASS_CODE)
  @javax.annotation.Nonnull
  private Integer serviceClassCode;

  public static final String SERIALIZED_NAME_ENTRY_ADDENDA_COUNT = "entryAddendaCount";
  @SerializedName(SERIALIZED_NAME_ENTRY_ADDENDA_COUNT)
  @javax.annotation.Nonnull
  private Integer entryAddendaCount;

  public static final String SERIALIZED_NAME_ENTRY_HASH = "entryHash";
  @SerializedName(SERIALIZED_NAME_ENTRY_HASH)
  @javax.annotation.Nonnull
  private Long entryHash;

  public static final String SERIALIZED_NAME_TOTAL_DEBIT = "totalDebit";
  @SerializedName(SERIALIZED_NAME_TOTAL_DEBIT)
  @javax.annotation.Nonnull
  private Long totalDebit;

  public static final String SERIALIZED_NAME_TOTAL_CREDIT = "totalCredit";
  @SerializedName(SERIALIZED_NAME_TOTAL_CREDIT)
  @javax.annotation.Nonnull
  private Long totalCredit;

  public static final String SERIALIZED_NAME_COMPANY_IDENTIFICATION = "companyIdentification";
  @SerializedName(SERIALIZED_NAME_COMPANY_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String companyIdentification;

  public static final String SERIALIZED_NAME_MESSAGE_AUTHENTICATION = "messageAuthentication";
  @SerializedName(SERIALIZED_NAME_MESSAGE_AUTHENTICATION)
  @javax.annotation.Nullable
  private String messageAuthentication;

  public static final String SERIALIZED_NAME_OD_F_I_IDENTIFICATION = "ODFIIdentification";
  @SerializedName(SERIALIZED_NAME_OD_F_I_IDENTIFICATION)
  @javax.annotation.Nonnull
  private String odFIIdentification;

  public static final String SERIALIZED_NAME_BATCH_NUMBER = "batchNumber";
  @SerializedName(SERIALIZED_NAME_BATCH_NUMBER)
  @javax.annotation.Nonnull
  private Integer batchNumber;

  public static final String SERIALIZED_NAME_LINE_NUMBER = "lineNumber";
  @SerializedName(SERIALIZED_NAME_LINE_NUMBER)
  @javax.annotation.Nullable
  private Integer lineNumber;

  public BatchControl() {
  }

  public BatchControl id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * Batch ID
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public BatchControl serviceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
    return this;
  }

  /**
   * Same as ServiceClassCode in BatchHeaderRecord
   * @return serviceClassCode
   */
  @javax.annotation.Nonnull
  public Integer getServiceClassCode() {
    return serviceClassCode;
  }

  public void setServiceClassCode(@javax.annotation.Nonnull Integer serviceClassCode) {
    this.serviceClassCode = serviceClassCode;
  }


  public BatchControl entryAddendaCount(@javax.annotation.Nonnull Integer entryAddendaCount) {
    this.entryAddendaCount = entryAddendaCount;
    return this;
  }

  /**
   * EntryAddendaCount is a tally of each Entry Detail Record and each Addenda Record processed, within either the batch or file as appropriate.
   * @return entryAddendaCount
   */
  @javax.annotation.Nonnull
  public Integer getEntryAddendaCount() {
    return entryAddendaCount;
  }

  public void setEntryAddendaCount(@javax.annotation.Nonnull Integer entryAddendaCount) {
    this.entryAddendaCount = entryAddendaCount;
  }


  public BatchControl entryHash(@javax.annotation.Nonnull Long entryHash) {
    this.entryHash = entryHash;
    return this;
  }

  /**
   * Validate the Receiving DFI Identification in each Entry Detail Record is hashed to provide a check against inadvertent alteration of data contents due to hardware failure or program error. In this context the Entry Hash is the sum of the corresponding fields in the Entry Detail Records on the file. 
   * @return entryHash
   */
  @javax.annotation.Nonnull
  public Long getEntryHash() {
    return entryHash;
  }

  public void setEntryHash(@javax.annotation.Nonnull Long entryHash) {
    this.entryHash = entryHash;
  }


  public BatchControl totalDebit(@javax.annotation.Nonnull Long totalDebit) {
    this.totalDebit = totalDebit;
    return this;
  }

  /**
   * Contains accumulated Entry debit totals within the batch.
   * @return totalDebit
   */
  @javax.annotation.Nonnull
  public Long getTotalDebit() {
    return totalDebit;
  }

  public void setTotalDebit(@javax.annotation.Nonnull Long totalDebit) {
    this.totalDebit = totalDebit;
  }


  public BatchControl totalCredit(@javax.annotation.Nonnull Long totalCredit) {
    this.totalCredit = totalCredit;
    return this;
  }

  /**
   * Contains accumulated Entry credit totals within the batch.
   * @return totalCredit
   */
  @javax.annotation.Nonnull
  public Long getTotalCredit() {
    return totalCredit;
  }

  public void setTotalCredit(@javax.annotation.Nonnull Long totalCredit) {
    this.totalCredit = totalCredit;
  }


  public BatchControl companyIdentification(@javax.annotation.Nonnull String companyIdentification) {
    this.companyIdentification = companyIdentification;
    return this;
  }

  /**
   * Alphanumeric code used to identify an Originator. The Company Identification Field must be included on all prenotification records and on each entry initiated pursuant to such prenotification. The Company ID may begin with the ANSI one-digit Identification Code Designator (ICD), followed by the identification number. Possible ICDs are the IRS Employer Identification Number (EIN) \&quot;1\&quot;, Data Universal Numbering Systems (DUNS) \&quot;3\&quot;, and User Assigned Number \&quot;9\&quot;. 
   * @return companyIdentification
   */
  @javax.annotation.Nonnull
  public String getCompanyIdentification() {
    return companyIdentification;
  }

  public void setCompanyIdentification(@javax.annotation.Nonnull String companyIdentification) {
    this.companyIdentification = companyIdentification;
  }


  public BatchControl messageAuthentication(@javax.annotation.Nullable String messageAuthentication) {
    this.messageAuthentication = messageAuthentication;
    return this;
  }

  /**
   * MAC is an eight character code derived from a special key used in conjunction with the DES algorithm. The purpose of the MAC is to validate the authenticity of ACH entries. The DES algorithm and key message standards must be in accordance with standards adopted by the American National Standards Institute. The remaining eleven characters of this field are blank.
   * @return messageAuthentication
   */
  @javax.annotation.Nullable
  public String getMessageAuthentication() {
    return messageAuthentication;
  }

  public void setMessageAuthentication(@javax.annotation.Nullable String messageAuthentication) {
    this.messageAuthentication = messageAuthentication;
  }


  public BatchControl odFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
    return this;
  }

  /**
   * The routing number is used to identify the DFI originating entries within a given branch.
   * @return odFIIdentification
   */
  @javax.annotation.Nonnull
  public String getOdFIIdentification() {
    return odFIIdentification;
  }

  public void setOdFIIdentification(@javax.annotation.Nonnull String odFIIdentification) {
    this.odFIIdentification = odFIIdentification;
  }


  public BatchControl batchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
    return this;
  }

  /**
   * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record.
   * @return batchNumber
   */
  @javax.annotation.Nonnull
  public Integer getBatchNumber() {
    return batchNumber;
  }

  public void setBatchNumber(@javax.annotation.Nonnull Integer batchNumber) {
    this.batchNumber = batchNumber;
  }


  public BatchControl lineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
    return this;
  }

  /**
   * Line number at which the record appears in the file.
   * @return lineNumber
   */
  @javax.annotation.Nullable
  public Integer getLineNumber() {
    return lineNumber;
  }

  public void setLineNumber(@javax.annotation.Nullable Integer lineNumber) {
    this.lineNumber = lineNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchControl batchControl = (BatchControl) o;
    return Objects.equals(this.id, batchControl.id) &&
        Objects.equals(this.serviceClassCode, batchControl.serviceClassCode) &&
        Objects.equals(this.entryAddendaCount, batchControl.entryAddendaCount) &&
        Objects.equals(this.entryHash, batchControl.entryHash) &&
        Objects.equals(this.totalDebit, batchControl.totalDebit) &&
        Objects.equals(this.totalCredit, batchControl.totalCredit) &&
        Objects.equals(this.companyIdentification, batchControl.companyIdentification) &&
        Objects.equals(this.messageAuthentication, batchControl.messageAuthentication) &&
        Objects.equals(this.odFIIdentification, batchControl.odFIIdentification) &&
        Objects.equals(this.batchNumber, batchControl.batchNumber) &&
        Objects.equals(this.lineNumber, batchControl.lineNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, serviceClassCode, entryAddendaCount, entryHash, totalDebit, totalCredit, companyIdentification, messageAuthentication, odFIIdentification, batchNumber, lineNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchControl {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    serviceClassCode: ").append(toIndentedString(serviceClassCode)).append("\n");
    sb.append("    entryAddendaCount: ").append(toIndentedString(entryAddendaCount)).append("\n");
    sb.append("    entryHash: ").append(toIndentedString(entryHash)).append("\n");
    sb.append("    totalDebit: ").append(toIndentedString(totalDebit)).append("\n");
    sb.append("    totalCredit: ").append(toIndentedString(totalCredit)).append("\n");
    sb.append("    companyIdentification: ").append(toIndentedString(companyIdentification)).append("\n");
    sb.append("    messageAuthentication: ").append(toIndentedString(messageAuthentication)).append("\n");
    sb.append("    odFIIdentification: ").append(toIndentedString(odFIIdentification)).append("\n");
    sb.append("    batchNumber: ").append(toIndentedString(batchNumber)).append("\n");
    sb.append("    lineNumber: ").append(toIndentedString(lineNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("id", "serviceClassCode", "entryAddendaCount", "entryHash", "totalDebit", "totalCredit", "companyIdentification", "messageAuthentication", "ODFIIdentification", "batchNumber", "lineNumber"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("serviceClassCode", "entryAddendaCount", "entryHash", "totalDebit", "totalCredit", "companyIdentification", "ODFIIdentification", "batchNumber"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchControl
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchControl.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchControl is not found in the empty JSON string", BatchControl.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchControl.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchControl` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : BatchControl.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("companyIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("companyIdentification").toString()));
      }
      if ((jsonObj.get("messageAuthentication") != null && !jsonObj.get("messageAuthentication").isJsonNull()) && !jsonObj.get("messageAuthentication").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `messageAuthentication` to be a primitive type in the JSON string but got `%s`", jsonObj.get("messageAuthentication").toString()));
      }
      if (!jsonObj.get("ODFIIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ODFIIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ODFIIdentification").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchControl.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchControl' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchControl> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchControl.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchControl>() {
           @Override
           public void write(JsonWriter out, BatchControl value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchControl read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchControl given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchControl
   * @throws IOException if the JSON string is invalid with respect to BatchControl
   */
  public static BatchControl fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchControl.class);
  }

  /**
   * Convert an instance of BatchControl to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

