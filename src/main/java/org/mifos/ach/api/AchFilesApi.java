/*
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.mifos.ach.api;

import org.mifos.ach.ApiCallback;
import org.mifos.ach.ApiClient;
import org.mifos.ach.ApiException;
import org.mifos.ach.ApiResponse;
import org.mifos.ach.Configuration;
import org.mifos.ach.Pair;
import org.mifos.ach.ProgressRequestBody;
import org.mifos.ach.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.mifos.ach.model.Batch;
import org.mifos.ach.model.CreateFile;
import org.mifos.ach.model.CreateFileResponse;
import org.mifos.ach.model.Error;
import org.mifos.ach.model.FlattenFileResponse;
import org.mifos.ach.model.MergeFilesRequest;
import org.mifos.ach.model.MergeFilesResponse;
import org.mifos.ach.model.ModelFile;
import org.mifos.ach.model.SegmentFile;
import org.mifos.ach.model.SegmentedFiles;
import java.net.URI;
import org.mifos.ach.model.ValidateOpts;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AchFilesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AchFilesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AchFilesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for addBatchToFile
     * @param fileID File ID (required)
     * @param batch  (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch added to File </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addBatchToFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull Batch batch, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batch;

        // create path and map variables
        String localVarPath = "/files/{fileID}/batches"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addBatchToFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull Batch batch, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling addBatchToFile(Async)");
        }

        // verify the required parameter 'batch' is set
        if (batch == null) {
            throw new ApiException("Missing the required parameter 'batch' when calling addBatchToFile(Async)");
        }

        return addBatchToFileCall(fileID, batch, xRequestID, _callback);

    }

    /**
     * Append Batch to File
     * Append a Batch record to the specified File.
     * @param fileID File ID (required)
     * @param batch  (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch added to File </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public void addBatchToFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull Batch batch, @javax.annotation.Nullable String xRequestID) throws ApiException {
        addBatchToFileWithHttpInfo(fileID, batch, xRequestID);
    }

    /**
     * Append Batch to File
     * Append a Batch record to the specified File.
     * @param fileID File ID (required)
     * @param batch  (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch added to File </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> addBatchToFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull Batch batch, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = addBatchToFileValidateBeforeCall(fileID, batch, xRequestID, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Append Batch to File (asynchronously)
     * Append a Batch record to the specified File.
     * @param fileID File ID (required)
     * @param batch  (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch added to File </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addBatchToFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull Batch batch, @javax.annotation.Nullable String xRequestID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = addBatchToFileValidateBeforeCall(fileID, batch, xRequestID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for buildFile
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call buildFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/build"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call buildFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling buildFile(Async)");
        }

        return buildFileCall(fileID, xRequestID, _callback);

    }

    /**
     * Build File
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ModelFile
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public ModelFile buildFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<ModelFile> localVarResp = buildFileWithHttpInfo(fileID, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Build File
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelFile> buildFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = buildFileValidateBeforeCall(fileID, xRequestID, null);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build File (asynchronously)
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call buildFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback<ModelFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = buildFileValidateBeforeCall(fileID, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for checkFile
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/validate"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (skipAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipAll", skipAll));
        }

        if (requireABAOrigin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireABAOrigin", requireABAOrigin));
        }

        if (bypassOriginValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassOriginValidation", bypassOriginValidation));
        }

        if (bypassDestinationValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassDestinationValidation", bypassDestinationValidation));
        }

        if (customTraceNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customTraceNumbers", customTraceNumbers));
        }

        if (allowZeroBatches != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowZeroBatches", allowZeroBatches));
        }

        if (allowMissingFileHeader != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileHeader", allowMissingFileHeader));
        }

        if (allowMissingFileControl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileControl", allowMissingFileControl));
        }

        if (bypassCompanyIdentificationMatch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassCompanyIdentificationMatch", bypassCompanyIdentificationMatch));
        }

        if (customReturnCodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customReturnCodes", customReturnCodes));
        }

        if (unequalServiceClassCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalServiceClassCode", unequalServiceClassCode));
        }

        if (allowUnorderedBatchNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowUnorderedBatchNumbers", allowUnorderedBatchNumbers));
        }

        if (allowInvalidCheckDigit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidCheckDigit", allowInvalidCheckDigit));
        }

        if (unequalAddendaCounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalAddendaCounts", unequalAddendaCounts));
        }

        if (preserveSpaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preserveSpaces", preserveSpaces));
        }

        if (allowInvalidAmounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidAmounts", allowInvalidAmounts));
        }

        if (allowSpecialCharacters != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowSpecialCharacters", allowSpecialCharacters));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call checkFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling checkFile(Async)");
        }

        return checkFileCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, _callback);

    }

    /**
     * Validate File
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return Error
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public Error checkFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<Error> localVarResp = checkFileWithHttpInfo(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Validate File
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;Error&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Error> checkFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = checkFileValidateBeforeCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, null);
        Type localVarReturnType = new TypeToken<Error>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Validate File (asynchronously)
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, final ApiCallback<Error> _callback) throws ApiException {

        okhttp3.Call localVarCall = checkFileValidateBeforeCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<Error>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createFile
     * @param fileID File ID (required)
     * @param body Content of the ACH file (in json or raw text) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestination Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param unorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a new File </td><td>  * Location - The location of the new resource <br>  </td></tr>
        <tr><td> 400 </td><td> Invalid File Header Object </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String body, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestination, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean unorderedBatchNumbers, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/files/{fileID}"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (skipAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipAll", skipAll));
        }

        if (requireABAOrigin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireABAOrigin", requireABAOrigin));
        }

        if (bypassOrigin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassOrigin", bypassOrigin));
        }

        if (bypassOriginValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassOriginValidation", bypassOriginValidation));
        }

        if (bypassDestination != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassDestination", bypassDestination));
        }

        if (bypassDestinationValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassDestinationValidation", bypassDestinationValidation));
        }

        if (customTraceNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customTraceNumbers", customTraceNumbers));
        }

        if (allowZeroBatches != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowZeroBatches", allowZeroBatches));
        }

        if (allowMissingFileHeader != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileHeader", allowMissingFileHeader));
        }

        if (allowMissingFileControl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileControl", allowMissingFileControl));
        }

        if (bypassCompanyIdentificationMatch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassCompanyIdentificationMatch", bypassCompanyIdentificationMatch));
        }

        if (customReturnCodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customReturnCodes", customReturnCodes));
        }

        if (unequalServiceClassCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalServiceClassCode", unequalServiceClassCode));
        }

        if (unorderedBatchNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unorderedBatchNumbers", unorderedBatchNumbers));
        }

        if (allowUnorderedBatchNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowUnorderedBatchNumbers", allowUnorderedBatchNumbers));
        }

        if (allowInvalidCheckDigit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidCheckDigit", allowInvalidCheckDigit));
        }

        if (unequalAddendaCounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalAddendaCounts", unequalAddendaCounts));
        }

        if (preserveSpaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preserveSpaces", preserveSpaces));
        }

        if (allowInvalidAmounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidAmounts", allowInvalidAmounts));
        }

        if (allowSpecialCharacters != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowSpecialCharacters", allowSpecialCharacters));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain",
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String body, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestination, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean unorderedBatchNumbers, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling createFile(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createFile(Async)");
        }

        return createFileCall(fileID, body, xRequestID, skipAll, requireABAOrigin, bypassOrigin, bypassOriginValidation, bypassDestination, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, unorderedBatchNumbers, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, _callback);

    }

    /**
     * Create File
     * Create a new File object from either the plaintext or JSON representation.
     * @param fileID File ID (required)
     * @param body Content of the ACH file (in json or raw text) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestination Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param unorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @return CreateFileResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a new File </td><td>  * Location - The location of the new resource <br>  </td></tr>
        <tr><td> 400 </td><td> Invalid File Header Object </td><td>  -  </td></tr>
     </table>
     */
    public CreateFileResponse createFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String body, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestination, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean unorderedBatchNumbers, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters) throws ApiException {
        ApiResponse<CreateFileResponse> localVarResp = createFileWithHttpInfo(fileID, body, xRequestID, skipAll, requireABAOrigin, bypassOrigin, bypassOriginValidation, bypassDestination, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, unorderedBatchNumbers, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters);
        return localVarResp.getData();
    }

    /**
     * Create File
     * Create a new File object from either the plaintext or JSON representation.
     * @param fileID File ID (required)
     * @param body Content of the ACH file (in json or raw text) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestination Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param unorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @return ApiResponse&lt;CreateFileResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a new File </td><td>  * Location - The location of the new resource <br>  </td></tr>
        <tr><td> 400 </td><td> Invalid File Header Object </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateFileResponse> createFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String body, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestination, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean unorderedBatchNumbers, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters) throws ApiException {
        okhttp3.Call localVarCall = createFileValidateBeforeCall(fileID, body, xRequestID, skipAll, requireABAOrigin, bypassOrigin, bypassOriginValidation, bypassDestination, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, unorderedBatchNumbers, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, null);
        Type localVarReturnType = new TypeToken<CreateFileResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create File (asynchronously)
     * Create a new File object from either the plaintext or JSON representation.
     * @param fileID File ID (required)
     * @param body Content of the ACH file (in json or raw text) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestination Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param unorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a new File </td><td>  * Location - The location of the new resource <br>  </td></tr>
        <tr><td> 400 </td><td> Invalid File Header Object </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String body, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestination, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean unorderedBatchNumbers, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, final ApiCallback<CreateFileResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createFileValidateBeforeCall(fileID, body, xRequestID, skipAll, requireABAOrigin, bypassOrigin, bypassOriginValidation, bypassDestination, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, unorderedBatchNumbers, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, _callback);
        Type localVarReturnType = new TypeToken<CreateFileResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteACHFile
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Permanently deleted File. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A File with the specified ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteACHFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteACHFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling deleteACHFile(Async)");
        }

        return deleteACHFileCall(fileID, xRequestID, _callback);

    }

    /**
     * Delete File
     * Permanently deletes a File and associated Batches. It cannot be undone.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Permanently deleted File. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A File with the specified ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteACHFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        deleteACHFileWithHttpInfo(fileID, xRequestID);
    }

    /**
     * Delete File
     * Permanently deletes a File and associated Batches. It cannot be undone.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Permanently deleted File. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A File with the specified ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteACHFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = deleteACHFileValidateBeforeCall(fileID, xRequestID, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete File (asynchronously)
     * Permanently deletes a File and associated Batches. It cannot be undone.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Permanently deleted File. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A File with the specified ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteACHFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteACHFileValidateBeforeCall(fileID, xRequestID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteFileBatch
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteFileBatchCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/batches/{batchID}"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()))
            .replace("{" + "batchID" + "}", localVarApiClient.escapeString(batchID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteFileBatchValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling deleteFileBatch(Async)");
        }

        // verify the required parameter 'batchID' is set
        if (batchID == null) {
            throw new ApiException("Missing the required parameter 'batchID' when calling deleteFileBatch(Async)");
        }

        return deleteFileBatchCall(fileID, batchID, xRequestID, _callback);

    }

    /**
     * Delete Batch
     * Delete a Batch from a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public void deleteFileBatch(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        deleteFileBatchWithHttpInfo(fileID, batchID, xRequestID);
    }

    /**
     * Delete Batch
     * Delete a Batch from a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteFileBatchWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = deleteFileBatchValidateBeforeCall(fileID, batchID, xRequestID, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Batch (asynchronously)
     * Delete a Batch from a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteFileBatchAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteFileBatchValidateBeforeCall(fileID, batchID, xRequestID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for flattenFile
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of the new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call flattenFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/flatten"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call flattenFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling flattenFile(Async)");
        }

        return flattenFileCall(fileID, xRequestID, _callback);

    }

    /**
     * Flatten Batches
     * Consolidate Batches and Entries into the minimum number of Batches needed.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return FlattenFileResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of the new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public FlattenFileResponse flattenFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<FlattenFileResponse> localVarResp = flattenFileWithHttpInfo(fileID, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Flatten Batches
     * Consolidate Batches and Entries into the minimum number of Batches needed.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;FlattenFileResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of the new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FlattenFileResponse> flattenFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = flattenFileValidateBeforeCall(fileID, xRequestID, null);
        Type localVarReturnType = new TypeToken<FlattenFileResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Flatten Batches (asynchronously)
     * Consolidate Batches and Entries into the minimum number of Batches needed.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of the new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call flattenFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback<FlattenFileResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = flattenFileValidateBeforeCall(fileID, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<FlattenFileResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFileBatch
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileBatchCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/batches/{batchID}"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()))
            .replace("{" + "batchID" + "}", localVarApiClient.escapeString(batchID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFileBatchValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling getFileBatch(Async)");
        }

        // verify the required parameter 'batchID' is set
        if (batchID == null) {
            throw new ApiException("Missing the required parameter 'batchID' when calling getFileBatch(Async)");
        }

        return getFileBatchCall(fileID, batchID, xRequestID, _callback);

    }

    /**
     * Get Batch
     * Get a specific Batch on a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return Batch
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public Batch getFileBatch(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<Batch> localVarResp = getFileBatchWithHttpInfo(fileID, batchID, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Get Batch
     * Get a specific Batch on a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;Batch&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Batch> getFileBatchWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = getFileBatchValidateBeforeCall(fileID, batchID, xRequestID, null);
        Type localVarReturnType = new TypeToken<Batch>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Batch (asynchronously)
     * Get a specific Batch on a File.
     * @param fileID File ID (required)
     * @param batchID Batch ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Batch or File not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileBatchAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nonnull String batchID, @javax.annotation.Nullable String xRequestID, final ApiCallback<Batch> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFileBatchValidateBeforeCall(fileID, batchID, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<Batch>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFileBatches
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Batch objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getFileBatchesCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/batches"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFileBatchesValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling getFileBatches(Async)");
        }

        return getFileBatchesCall(fileID, xRequestID, _callback);

    }

    /**
     * Get Batches
     * Get the Batches on a File.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return List&lt;Batch&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Batch objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public List<Batch> getFileBatches(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<List<Batch>> localVarResp = getFileBatchesWithHttpInfo(fileID, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Get Batches
     * Get the Batches on a File.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;List&lt;Batch&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Batch objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public ApiResponse<List<Batch>> getFileBatchesWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = getFileBatchesValidateBeforeCall(fileID, xRequestID, null);
        Type localVarReturnType = new TypeToken<List<Batch>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Batches (asynchronously)
     * Get the Batches on a File.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Batch objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getFileBatchesAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback<List<Batch>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFileBatchesValidateBeforeCall(fileID, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<List<Batch>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFileByID
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A File object for the supplied ID </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileByIDCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFileByIDValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling getFileByID(Async)");
        }

        return getFileByIDCall(fileID, xRequestID, _callback);

    }

    /**
     * Retrieve File
     * Get the details of an existing File using the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ModelFile
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A File object for the supplied ID </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ModelFile getFileByID(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<ModelFile> localVarResp = getFileByIDWithHttpInfo(fileID, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Retrieve File
     * Get the details of an existing File using the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A File object for the supplied ID </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelFile> getFileByIDWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = getFileByIDValidateBeforeCall(fileID, xRequestID, null);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve File (asynchronously)
     * Get the details of an existing File using the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A File object for the supplied ID </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileByIDAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, final ApiCallback<ModelFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFileByIDValidateBeforeCall(fileID, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFileContents
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param xLineEnding Optional Line Ending allows application developer to alter line ending of the file data returned. Supported choices are LF (Line Feed) and CRLF (Carriage Return Line Feed). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileContentsCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String xLineEnding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files/{fileID}/contents"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        if (xLineEnding != null) {
            localVarHeaderParams.put("X-Line-Ending", localVarApiClient.parameterToString(xLineEnding));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFileContentsValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String xLineEnding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling getFileContents(Async)");
        }

        return getFileContentsCall(fileID, xRequestID, xLineEnding, _callback);

    }

    /**
     * Get File Contents
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param xLineEnding Optional Line Ending allows application developer to alter line ending of the file data returned. Supported choices are LF (Line Feed) and CRLF (Carriage Return Line Feed). (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public String getFileContents(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String xLineEnding) throws ApiException {
        ApiResponse<String> localVarResp = getFileContentsWithHttpInfo(fileID, xRequestID, xLineEnding);
        return localVarResp.getData();
    }

    /**
     * Get File Contents
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param xLineEnding Optional Line Ending allows application developer to alter line ending of the file data returned. Supported choices are LF (Line Feed) and CRLF (Carriage Return Line Feed). (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getFileContentsWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String xLineEnding) throws ApiException {
        okhttp3.Call localVarCall = getFileContentsValidateBeforeCall(fileID, xRequestID, xLineEnding, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get File Contents (asynchronously)
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param xLineEnding Optional Line Ending allows application developer to alter line ending of the file data returned. Supported choices are LF (Line Feed) and CRLF (Carriage Return Line Feed). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File built successfully without errors. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFileContentsAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String xLineEnding, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFileContentsValidateBeforeCall(fileID, xRequestID, xLineEnding, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFiles
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of File objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getFilesCall(@javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFilesValidateBeforeCall(@javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        return getFilesCall(xRequestID, _callback);

    }

    /**
     * List Files
     * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return List&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of File objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public List<ModelFile> getFiles(@javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<List<ModelFile>> localVarResp = getFilesWithHttpInfo(xRequestID);
        return localVarResp.getData();
    }

    /**
     * List Files
     * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;List&lt;ModelFile&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of File objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelFile>> getFilesWithHttpInfo(@javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = getFilesValidateBeforeCall(xRequestID, null);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Files (asynchronously)
     * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of File objects </td><td>  * X-Total-Count - The total number of Batches on the File. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getFilesAsync(@javax.annotation.Nullable String xRequestID, final ApiCallback<List<ModelFile>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFilesValidateBeforeCall(xRequestID, _callback);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for mergeFiles
     * @param mergeFilesRequest JSON object containing FileIDs and ACH files (in JSON format) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Files were merged together </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call mergeFilesCall(@javax.annotation.Nonnull MergeFilesRequest mergeFilesRequest, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = mergeFilesRequest;

        // create path and map variables
        String localVarPath = "/merge";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call mergeFilesValidateBeforeCall(@javax.annotation.Nonnull MergeFilesRequest mergeFilesRequest, @javax.annotation.Nullable String xRequestID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'mergeFilesRequest' is set
        if (mergeFilesRequest == null) {
            throw new ApiException("Missing the required parameter 'mergeFilesRequest' when calling mergeFiles(Async)");
        }

        return mergeFilesCall(mergeFilesRequest, xRequestID, _callback);

    }

    /**
     * Merge Files
     * Combine multiple fileIDs and files together. Returned is the results of merging
     * @param mergeFilesRequest JSON object containing FileIDs and ACH files (in JSON format) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return MergeFilesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Files were merged together </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public MergeFilesResponse mergeFiles(@javax.annotation.Nonnull MergeFilesRequest mergeFilesRequest, @javax.annotation.Nullable String xRequestID) throws ApiException {
        ApiResponse<MergeFilesResponse> localVarResp = mergeFilesWithHttpInfo(mergeFilesRequest, xRequestID);
        return localVarResp.getData();
    }

    /**
     * Merge Files
     * Combine multiple fileIDs and files together. Returned is the results of merging
     * @param mergeFilesRequest JSON object containing FileIDs and ACH files (in JSON format) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @return ApiResponse&lt;MergeFilesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Files were merged together </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MergeFilesResponse> mergeFilesWithHttpInfo(@javax.annotation.Nonnull MergeFilesRequest mergeFilesRequest, @javax.annotation.Nullable String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = mergeFilesValidateBeforeCall(mergeFilesRequest, xRequestID, null);
        Type localVarReturnType = new TypeToken<MergeFilesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Merge Files (asynchronously)
     * Combine multiple fileIDs and files together. Returned is the results of merging
     * @param mergeFilesRequest JSON object containing FileIDs and ACH files (in JSON format) (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Files were merged together </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call mergeFilesAsync(@javax.annotation.Nonnull MergeFilesRequest mergeFilesRequest, @javax.annotation.Nullable String xRequestID, final ApiCallback<MergeFilesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = mergeFilesValidateBeforeCall(mergeFilesRequest, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<MergeFilesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for ping
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Service is running properly </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pingCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ping";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pingValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return pingCall(_callback);

    }

    /**
     * Ping ACH service
     * Check if the ACH service is running.
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Service is running properly </td><td>  -  </td></tr>
     </table>
     */
    public void ping() throws ApiException {
        pingWithHttpInfo();
    }

    /**
     * Ping ACH service
     * Check if the ACH service is running.
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Service is running properly </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pingWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = pingValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Ping ACH service (asynchronously)
     * Check if the ACH service is running.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Service is running properly </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pingAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pingValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for segmentFile
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body ACH file (in Nacha or JSON formatting) along with optional segment configuration (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call segmentFileCall(@javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/segment";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain",
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call segmentFileValidateBeforeCall(@javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String body, final ApiCallback _callback) throws ApiException {
        return segmentFileCall(xRequestID, body, _callback);

    }

    /**
     * Segment File
     * Split one File into two. One with only debits and one with only credits.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body ACH file (in Nacha or JSON formatting) along with optional segment configuration (optional)
     * @return SegmentedFiles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public SegmentedFiles segmentFile(@javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String body) throws ApiException {
        ApiResponse<SegmentedFiles> localVarResp = segmentFileWithHttpInfo(xRequestID, body);
        return localVarResp.getData();
    }

    /**
     * Segment File
     * Split one File into two. One with only debits and one with only credits.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body ACH file (in Nacha or JSON formatting) along with optional segment configuration (optional)
     * @return ApiResponse&lt;SegmentedFiles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SegmentedFiles> segmentFileWithHttpInfo(@javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String body) throws ApiException {
        okhttp3.Call localVarCall = segmentFileValidateBeforeCall(xRequestID, body, null);
        Type localVarReturnType = new TypeToken<SegmentedFiles>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Segment File (asynchronously)
     * Split one File into two. One with only debits and one with only credits.
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body ACH file (in Nacha or JSON formatting) along with optional segment configuration (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call segmentFileAsync(@javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable String body, final ApiCallback<SegmentedFiles> _callback) throws ApiException {

        okhttp3.Call localVarCall = segmentFileValidateBeforeCall(xRequestID, body, _callback);
        Type localVarReturnType = new TypeToken<SegmentedFiles>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for segmentFileID
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body Optional configuration for segmenting files (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call segmentFileIDCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/files/{fileID}/segment"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call segmentFileIDValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling segmentFileID(Async)");
        }

        return segmentFileIDCall(fileID, xRequestID, body, _callback);

    }

    /**
     * Segment FileID
     * Split one FileID into two. One with only debits and one with only credits.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body Optional configuration for segmenting files (optional)
     * @return SegmentedFiles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public SegmentedFiles segmentFileID(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Object body) throws ApiException {
        ApiResponse<SegmentedFiles> localVarResp = segmentFileIDWithHttpInfo(fileID, xRequestID, body);
        return localVarResp.getData();
    }

    /**
     * Segment FileID
     * Split one FileID into two. One with only debits and one with only credits.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body Optional configuration for segmenting files (optional)
     * @return ApiResponse&lt;SegmentedFiles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SegmentedFiles> segmentFileIDWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Object body) throws ApiException {
        okhttp3.Call localVarCall = segmentFileIDValidateBeforeCall(fileID, xRequestID, body, null);
        Type localVarReturnType = new TypeToken<SegmentedFiles>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Segment FileID (asynchronously)
     * Split one FileID into two. One with only debits and one with only credits.
     * @param fileID File ID (required)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param body Optional configuration for segmenting files (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ID of each new ACH file </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> See error in response body </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A resource with the specified ID was not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call segmentFileIDAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable Object body, final ApiCallback<SegmentedFiles> _callback) throws ApiException {

        okhttp3.Call localVarCall = segmentFileIDValidateBeforeCall(fileID, xRequestID, body, _callback);
        Type localVarReturnType = new TypeToken<SegmentedFiles>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for validateFile
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param validateOpts  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call validateFileCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable ValidateOpts validateOpts, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = validateOpts;

        // create path and map variables
        String localVarPath = "/files/{fileID}/validate"
            .replace("{" + "fileID" + "}", localVarApiClient.escapeString(fileID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (skipAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipAll", skipAll));
        }

        if (requireABAOrigin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireABAOrigin", requireABAOrigin));
        }

        if (bypassOriginValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassOriginValidation", bypassOriginValidation));
        }

        if (bypassDestinationValidation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassDestinationValidation", bypassDestinationValidation));
        }

        if (customTraceNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customTraceNumbers", customTraceNumbers));
        }

        if (allowZeroBatches != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowZeroBatches", allowZeroBatches));
        }

        if (allowMissingFileHeader != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileHeader", allowMissingFileHeader));
        }

        if (allowMissingFileControl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowMissingFileControl", allowMissingFileControl));
        }

        if (bypassCompanyIdentificationMatch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bypassCompanyIdentificationMatch", bypassCompanyIdentificationMatch));
        }

        if (customReturnCodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("customReturnCodes", customReturnCodes));
        }

        if (unequalServiceClassCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalServiceClassCode", unequalServiceClassCode));
        }

        if (allowUnorderedBatchNumbers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowUnorderedBatchNumbers", allowUnorderedBatchNumbers));
        }

        if (allowInvalidCheckDigit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidCheckDigit", allowInvalidCheckDigit));
        }

        if (unequalAddendaCounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unequalAddendaCounts", unequalAddendaCounts));
        }

        if (preserveSpaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preserveSpaces", preserveSpaces));
        }

        if (allowInvalidAmounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowInvalidAmounts", allowInvalidAmounts));
        }

        if (allowSpecialCharacters != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowSpecialCharacters", allowSpecialCharacters));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xRequestID != null) {
            localVarHeaderParams.put("X-Request-ID", localVarApiClient.parameterToString(xRequestID));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call validateFileValidateBeforeCall(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable ValidateOpts validateOpts, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileID' is set
        if (fileID == null) {
            throw new ApiException("Missing the required parameter 'fileID' when calling validateFile(Async)");
        }

        return validateFileCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, validateOpts, _callback);

    }

    /**
     * Validate File (Custom)
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param validateOpts  (optional)
     * @return Error
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public Error validateFile(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable ValidateOpts validateOpts) throws ApiException {
        ApiResponse<Error> localVarResp = validateFileWithHttpInfo(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, validateOpts);
        return localVarResp.getData();
    }

    /**
     * Validate File (Custom)
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param validateOpts  (optional)
     * @return ApiResponse&lt;Error&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Error> validateFileWithHttpInfo(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable ValidateOpts validateOpts) throws ApiException {
        okhttp3.Call localVarCall = validateFileValidateBeforeCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, validateOpts, null);
        Type localVarReturnType = new TypeToken<Error>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Validate File (Custom) (asynchronously)
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @param fileID File ID (required)
     * @param skipAll Optional parameter to disable all validation checks for a File (optional)
     * @param requireABAOrigin Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassOriginValidation Optional parameter to configure ImmediateOrigin validation (optional)
     * @param bypassDestinationValidation Optional parameter to configure ImmediateDestination validation (optional)
     * @param customTraceNumbers Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowZeroBatches Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileHeader Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowMissingFileControl Optional parameter to configure ImmediateDestination validation (optional)
     * @param bypassCompanyIdentificationMatch Optional parameter to configure ImmediateDestination validation (optional)
     * @param customReturnCodes Optional parameter to configure ImmediateDestination validation (optional)
     * @param unequalServiceClassCode Optional parameter to configure ImmediateDestination validation (optional)
     * @param allowUnorderedBatchNumbers Allow a file to be read with unordered batch numbers. (optional)
     * @param allowInvalidCheckDigit Allow the CheckDigit field in EntryDetail to differ from the expected calculation (optional)
     * @param unequalAddendaCounts Optional parameter to configure UnequalAddendaCounts validation (optional)
     * @param preserveSpaces Optional parameter to save all padding spaces (optional)
     * @param allowInvalidAmounts Optional parameter to save all padding spaces (optional)
     * @param allowSpecialCharacters Optional parameter to permit a wider range of UTF-8 characters in alphanumeric fields (optional)
     * @param xRequestID Optional Request ID allows application developer to trace requests through the system&#39;s logs (optional)
     * @param validateOpts  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File validated successfully without errors. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Validation failed. Check response for errors </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call validateFileAsync(@javax.annotation.Nonnull String fileID, @javax.annotation.Nullable Boolean skipAll, @javax.annotation.Nullable Boolean requireABAOrigin, @javax.annotation.Nullable Boolean bypassOriginValidation, @javax.annotation.Nullable Boolean bypassDestinationValidation, @javax.annotation.Nullable Boolean customTraceNumbers, @javax.annotation.Nullable Boolean allowZeroBatches, @javax.annotation.Nullable Boolean allowMissingFileHeader, @javax.annotation.Nullable Boolean allowMissingFileControl, @javax.annotation.Nullable Boolean bypassCompanyIdentificationMatch, @javax.annotation.Nullable Boolean customReturnCodes, @javax.annotation.Nullable Boolean unequalServiceClassCode, @javax.annotation.Nullable Boolean allowUnorderedBatchNumbers, @javax.annotation.Nullable Boolean allowInvalidCheckDigit, @javax.annotation.Nullable Boolean unequalAddendaCounts, @javax.annotation.Nullable Boolean preserveSpaces, @javax.annotation.Nullable Boolean allowInvalidAmounts, @javax.annotation.Nullable Boolean allowSpecialCharacters, @javax.annotation.Nullable String xRequestID, @javax.annotation.Nullable ValidateOpts validateOpts, final ApiCallback<Error> _callback) throws ApiException {

        okhttp3.Call localVarCall = validateFileValidateBeforeCall(fileID, skipAll, requireABAOrigin, bypassOriginValidation, bypassDestinationValidation, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, allowUnorderedBatchNumbers, allowInvalidCheckDigit, unequalAddendaCounts, preserveSpaces, allowInvalidAmounts, allowSpecialCharacters, xRequestID, validateOpts, _callback);
        Type localVarReturnType = new TypeToken<Error>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
